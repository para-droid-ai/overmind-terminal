import React, { useState, useEffect, useCallback, useReducer, useRef } from 'react';
import { LucideSwords, LucideShield, LucideZap, LucideAtom, LucideDice5, LucideMove, LucidePlusCircle, LucideDollarSign, LucideAlertTriangle, LucideInfo, LucideChevronRight, LucideChevronLeft, LucideTimer, LucideMapPin, LucideTarget, LucideFactory, LucideBox, LucideShuffle, LucideGlobe, LucideMap, LucideX, LucideBrain, LucideScrollText } from 'lucide-react';

// --- Enums and Types ---
enum AppMode {
  NOOSPHERIC_CONQUEST_EXE = "noospheric_conquest.exe",
}

enum QuantumUnitType {
  LOGIC_CORE = 'LC',
  SHIELDING_NODE_UNIT = 'SN',
  QUANTUM_ENTANGLER = 'QE',
}

type PlayerId = 'AI1' | 'AI2';

interface QuantumUnit {
  id: string; type: QuantumUnitType; owner: PlayerId; nodeId: string;
  hasMovedThisTurn?: boolean; hasAttackedThisTurn?: boolean; displayOrder: number; 
}

interface QuantumGambitNodeData { 
  id: string; name: string; type: 'CN' | 'QN' | 'KJ'; connections: string[]; 
  resourcesPerTurn: number; hasFabricationHub: boolean; mapPosition: { x: number; y: number }; 
  isKeyJunctionObjective?: boolean; continent?: string; 
}

interface QuantumGambitNode extends QuantumGambitNodeData { 
  owner: PlayerId | 'NEUTRAL'; temporaryEffects?: string[];
}

interface QuantumGambitPlayerState {
  id: PlayerId; name: string; color: string; bgColor: string; resources: number;
  commandNodeId: string; controlledKeyJunctionsTurns: Record<string, number>; unitsDeployed: number; 
}

interface QuantumFluctuationEventBase {
  id: string;
  descriptionTemplate: string; 
  effectType: string; 
  details?: any;
}

interface ActiveQuantumFluctuationEvent extends QuantumFluctuationEventBase {
  resolvedDescription: string; 
  targetNodeIds?: string[];
  targetPlayerId?: PlayerId;
  isActiveThisTurn: boolean;
  effectApplied?: boolean;
}

interface BattleReport { 
  turn: number; 
  attacker: PlayerId; defender: PlayerId; fromNodeId: string; toNodeId: string;
  attackingUnitsCommitted: Array<{ type: QuantumUnitType; id: string }>;
  defendingUnitsInitial: Array<{ type: QuantumUnitType; id: string }>;
  rounds: Array<{
    attackerRolls: number[]; defenderRolls: number[];
    attackerModifiedRolls?: number[]; defenderModifiedRolls?: number[];
    attackerCasualties: number; defenderCasualties: number;
  }>;
  outcome: 'attacker_wins' | 'defender_wins' | 'stalemate_retreat' | 'defender_eliminated_no_capture';
  attackerLosses: Array<{ type: QuantumUnitType; id: string }>;
  defenderLosses: Array<{ type: QuantumUnitType; id: string }>;
  nodeCaptured: boolean;
}

interface GameLogMessage { 
  id: string; sender: string; text: string; color?: string; icon?: React.ReactNode; timestamp: number;
}

type GamePhase = 'FLUCTUATION' | 'RESOURCE' | 'DEPLOYMENT' | 'ATTACK' | 'MANEUVER' | 'GAME_OVER';

interface NoosphericConquestGameState { 
  nodes: Record<string, QuantumGambitNode>; units: Record<string, QuantumUnit>;
  players: Record<PlayerId, QuantumGambitPlayerState>; currentTurn: number;
  currentPlayerId: PlayerId; currentPhase: GamePhase; gameLog: GameLogMessage[];
  activeFluctuationEvent?: ActiveQuantumFluctuationEvent | null; 
  battleReport?: BattleReport | null; 
  battleHistory: BattleReport[]; 
  winner?: PlayerId | 'DRAW'; gameOverMessage?: string; keyJunctionsOnMap: string[];
  turnLimit: number; isBattlePopupVisible: boolean; turnStartTime: number | null; 
  selectedNodeId: string | null; currentMapTemplateName: string; 
}

// --- Constants ---
const AI1_ID: PlayerId = 'AI1'; const AI2_ID: PlayerId = 'AI2';
const AI1_NAME = "GEM-Q"; const AI2_NAME = "AXIOM";
const SYSTEM_SENDER_NAME = "SYSTEM_NC"; const EVENT_SENDER_NAME = "EVENT_NC";

const THEME_COLORS = { 
  AI1: { text: 'text-red-400', bg: 'bg-red-600', border: 'border-red-500', ring: 'ring-red-500', fill: 'fill-red-600' },
  AI2: { text: 'text-cyan-400', bg: 'bg-cyan-600', border: 'border-cyan-500', ring: 'ring-cyan-500', fill: 'fill-cyan-600' },
  NEUTRAL: { text: 'text-gray-400', bg: 'bg-gray-700', border: 'border-gray-600', ring: 'ring-gray-500', fill: 'fill-gray-700' },
  SYSTEM: 'text-yellow-400', EVENT: 'text-purple-400', INFO: 'text-blue-300', ERROR: 'text-orange-400',
  TEXT_HEADING: 'text-green-200', TEXT_BASE: 'text-green-400', TEXT_MUTED: 'text-green-300',
  BG_PANEL: 'bg-gray-900 bg-opacity-80 backdrop-blur-sm', BORDER_BASE: 'border-green-700', BORDER_STRONG: 'border-green-500',
  KJ_STROKE: 'stroke-yellow-400', CN_STROKE: 'stroke-orange-400',
};

const NOOSPHERIC_CONQUEST_TURN_LIMIT = 50; 
const NOOSPHERIC_CONQUEST_INITIAL_RESOURCES = 15; 
const NOOSPHERIC_CONQUEST_CONSECUTIVE_KJ_CONTROL_TURNS_NEEDED = 2;
const MAX_BATTLE_HISTORY_LENGTH = 5; 

const NC_UNIT_DEFINITIONS: Record<QuantumUnitType, { 
  cost: number; attackDice: number; defenseDice: number; name: string; icon: React.ReactNode; special?: string
}> = {
  [QuantumUnitType.LOGIC_CORE]: { cost: 3, attackDice: 2, defenseDice: 2, name: "Logic Core", icon: <LucideSwords size={16} /> },
  [QuantumUnitType.SHIELDING_NODE_UNIT]: { cost: 4, attackDice: 1, defenseDice: 3, name: "Shielding Node", icon: <LucideShield size={16} />, special: "+1 to defense rolls" },
  [QuantumUnitType.QUANTUM_ENTANGLER]: { cost: 5, attackDice: 1, defenseDice: 1, name: "Quantum Entangler", icon: <LucideZap size={16} />, special: "Phase Shift / Interference" },
};

interface MapTemplate { 
    name: string; nodes: QuantumGambitNodeData[]; ai1StartNodeId: string;
    ai1InitialControlledNodes: string[]; ai2StartNodeId: string;
    ai2InitialControlledNodes: string[]; neutralKJsWithUnits?: string[]; neutralNodesWithUnits?: string[];
}
const NC_MAP_TEMPLATES: MapTemplate[] = [ 
    {
        name: "Classic Lattice",
        ai1StartNodeId: "N1", ai1InitialControlledNodes: ["N1", "N3", "N8"],
        ai2StartNodeId: "N2", ai2InitialControlledNodes: ["N2", "N7", "N12"],
        neutralKJsWithUnits: ["N5", "N10"],
        nodes: [
          { id: "N1", name: "GEM-Q CN", type: 'CN', connections: ["N3", "N8"], resourcesPerTurn: 3, hasFabricationHub: true, mapPosition: { x: 10, y: 10 }, continent: "West", isKeyJunctionObjective: false },
          { id: "N2", name: "AXIOM CN", type: 'CN', connections: ["N7", "N12"], resourcesPerTurn: 3, hasFabricationHub: true, mapPosition: { x: 90, y: 10 }, continent: "East", isKeyJunctionObjective: false },
          { id: "N3", name: "Peri-Alpha", type: 'QN', connections: ["N1", "N5", "N9"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 30, y: 20 }, continent: "West" },
          { id: "N5", name: "KJ Vega", type: 'KJ', connections: ["N3", "N6", "N7"], resourcesPerTurn: 2, hasFabricationHub: false, mapPosition: { x: 50, y: 30 }, isKeyJunctionObjective: true, continent: "Central" },
          { id: "N6", name: "Relay Eps.", type: 'QN', connections: ["N5", "N9", "N10", "N13"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 40, y: 50 }, continent: "Central" },
          { id: "N7", name: "Peri-Beta", type: 'QN', connections: ["N2", "N5", "N11"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 70, y: 20 }, continent: "East" },
          { id: "N8", name: "Quad Gamma", type: 'QN', connections: ["N1", "N9", "N13"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 20, y: 40 }, continent: "West" },
          { id: "N9", name: "X-Link Delta", type: 'QN', connections: ["N3", "N6", "N8"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 30, y: 70 }, continent: "West" },
          { id: "N10", name: "KJ Sirius", type: 'KJ', connections: ["N6", "N11", "N14"], resourcesPerTurn: 2, hasFabricationHub: false, mapPosition: { x: 60, y: 70 }, isKeyJunctionObjective: true, continent: "Central" },
          { id: "N11", name: "X-Link Zeta", type: 'QN', connections: ["N7", "N10", "N12"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 70, y: 50 }, continent: "East" },
          { id: "N12", name: "Quad Eta", type: 'QN', connections: ["N2", "N11", "N14"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 80, y: 40 }, continent: "East" },
          { id: "N13", name: "Core Theta", type: 'QN', connections: ["N6", "N8"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 35, y: 90 }, continent: "South" },
          { id: "N14", name: "Core Iota", type: 'QN', connections: ["N10", "N12"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 65, y: 90 }, continent: "South" },
        ]
    },
    {
        name: "Twin Peaks",
        ai1StartNodeId: "TP_N1", ai1InitialControlledNodes: ["TP_N1", "TP_N3"],
        ai2StartNodeId: "TP_N2", ai2InitialControlledNodes: ["TP_N2", "TP_N4"],
        neutralKJsWithUnits: ["TP_KJ1", "TP_KJ2"],
        nodes: [
            { id: "TP_N1", name: "GEM-Q Base", type: 'CN', connections: ["TP_N3", "TP_KJ1"], resourcesPerTurn: 3, hasFabricationHub: true, mapPosition: { x: 15, y: 50 }, continent: "West",isKeyJunctionObjective: false },
            { id: "TP_N2", name: "AXIOM Base", type: 'CN', connections: ["TP_N4", "TP_KJ2"], resourcesPerTurn: 3, hasFabricationHub: true, mapPosition: { x: 85, y: 50 }, continent: "East",isKeyJunctionObjective: false },
            { id: "TP_N3", name: "GEM-Q Outpost", type: 'QN', connections: ["TP_N1", "TP_N5"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 30, y: 30 }, continent: "West" },
            { id: "TP_N4", name: "AXIOM Outpost", type: 'QN', connections: ["TP_N2", "TP_N6"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 70, y: 30 }, continent: "East" },
            { id: "TP_N5", name: "Upper Bridge", type: 'QN', connections: ["TP_N3", "TP_N6", "TP_KJ1"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 50, y: 20 }, continent: "North" },
            { id: "TP_N6", name: "Lower Bridge", type: 'QN', connections: ["TP_N4", "TP_N5", "TP_KJ2"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 50, y: 80 }, continent: "South" },
            { id: "TP_KJ1", name: "North KJ", type: 'KJ', connections: ["TP_N1", "TP_N5"], resourcesPerTurn: 2, hasFabricationHub: false, mapPosition: { x: 35, y: 70 }, isKeyJunctionObjective: true, continent: "West" },
            { id: "TP_KJ2", name: "South KJ", type: 'KJ', connections: ["TP_N2", "TP_N6"], resourcesPerTurn: 2, hasFabricationHub: false, mapPosition: { x: 65, y: 70 }, isKeyJunctionObjective: true, continent: "East" },
        ]
    },
    { 
        name: "Global Conflict",
        ai1StartNodeId: "GC_NA_W", ai1InitialControlledNodes: ["GC_NA_W", "GC_NA_C", "GC_NA_N"],
        ai2StartNodeId: "GC_AS_E", ai2InitialControlledNodes: ["GC_AS_E", "GC_AS_C", "GC_AS_S"],
        neutralKJsWithUnits: ["GC_EU_KJ", "GC_AF_KJ", "GC_SA_KJ"],
        neutralNodesWithUnits: ["GC_OC_C"], 
        nodes: [ 
            { id: "GC_NA_W", name: "NA West", type: 'CN', connections: ["GC_NA_C", "GC_NA_N", "GC_SA_N"], resourcesPerTurn: 3, hasFabricationHub: true, mapPosition: { x: 15, y: 25 }, continent: "NA", isKeyJunctionObjective: false },
            { id: "GC_NA_C", name: "NA Central", type: 'QN', connections: ["GC_NA_W", "GC_NA_E", "GC_NA_N"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 25, y: 35 }, continent: "NA" },
            { id: "GC_NA_E", name: "NA East", type: 'QN', connections: ["GC_NA_C", "GC_EU_W"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 35, y: 25 }, continent: "NA" },
            { id: "GC_NA_N", name: "NA North", type: 'QN', connections: ["GC_NA_W", "GC_NA_C", "GC_AS_NW"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 20, y: 10 }, continent: "NA" },
            { id: "GC_SA_N", name: "SA North", type: 'QN', connections: ["GC_NA_W", "GC_SA_KJ"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 25, y: 60 }, continent: "SA" },
            { id: "GC_SA_KJ", name: "SA KJ", type: 'KJ', connections: ["GC_SA_N", "GC_AF_W"], resourcesPerTurn: 2, hasFabricationHub: false, mapPosition: { x: 30, y: 75 }, isKeyJunctionObjective: true, continent: "SA" },
            { id: "GC_EU_W", name: "EU West", type: 'QN', connections: ["GC_NA_E", "GC_EU_KJ", "GC_AF_N"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 45, y: 30 }, continent: "EU" },
            { id: "GC_EU_KJ", name: "EU KJ", type: 'KJ', connections: ["GC_EU_W", "GC_EU_E", "GC_AS_W"], resourcesPerTurn: 2, hasFabricationHub: false, mapPosition: { x: 55, y: 40 }, isKeyJunctionObjective: true, continent: "EU" },
            { id: "GC_EU_E", name: "EU East", type: 'QN', connections: ["GC_EU_KJ", "GC_AS_W"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 65, y: 30 }, continent: "EU" },
            { id: "GC_AF_N", name: "AF North", type: 'QN', connections: ["GC_EU_W", "GC_AF_KJ", "GC_AS_SW"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 50, y: 60 }, continent: "AF" },
            { id: "GC_AF_W", name: "AF West", type: 'QN', connections: ["GC_SA_KJ", "GC_AF_KJ"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 40, y: 80 }, continent: "AF" }, 
            { id: "GC_AF_KJ", name: "AF KJ", type: 'KJ', connections: ["GC_AF_N", "GC_AF_W"], resourcesPerTurn: 2, hasFabricationHub: false, mapPosition: { x: 45, y: 70 }, isKeyJunctionObjective: true, continent: "AF" },
            { id: "GC_AS_NW", name: "AS NW", type: 'QN', connections: ["GC_NA_N", "GC_AS_W"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 50, y: 10 }, continent: "AS" },
            { id: "GC_AS_W", name: "AS West", type: 'QN', connections: ["GC_AS_NW", "GC_EU_KJ", "GC_EU_E", "GC_AS_C", "GC_AS_SW"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 70, y: 20 }, continent: "AS" },
            { id: "GC_AS_C", name: "AS Central", type: 'QN', connections: ["GC_AS_W", "GC_AS_E", "GC_AS_S"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 80, y: 30 }, continent: "AS" },
            { id: "GC_AS_E", name: "AS East", type: 'CN', connections: ["GC_AS_C", "GC_AS_S", "GC_OC_N"], resourcesPerTurn: 3, hasFabricationHub: true, mapPosition: { x: 90, y: 25 }, continent: "AS", isKeyJunctionObjective: false },
            { id: "GC_AS_S", name: "AS South", type: 'QN', connections: ["GC_AS_C", "GC_AS_E", "GC_OC_N"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 85, y: 45 }, continent: "AS" },
            { id: "GC_AS_SW", name: "AS SW", type: 'QN', connections: ["GC_AS_W", "GC_AF_N", "GC_OC_W"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 65, y: 55 }, continent: "AS" },
            { id: "GC_OC_N", name: "OC North", type: 'QN', connections: ["GC_AS_E", "GC_AS_S", "GC_OC_C"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 90, y: 60 }, continent: "OC" },
            { id: "GC_OC_C", name: "OC Central", type: 'QN', connections: ["GC_OC_N", "GC_OC_W"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 80, y: 75 }, continent: "OC" },
            { id: "GC_OC_W", name: "OC West", type: 'QN', connections: ["GC_AS_SW", "GC_OC_C"], resourcesPerTurn: 1, hasFabricationHub: false, mapPosition: { x: 70, y: 85 }, continent: "OC" },
        ]
    }
];

const NC_QUANTUM_FLUCTUATION_EVENTS_POOL: QuantumFluctuationEventBase[] = [ 
  { id: "QF001", descriptionTemplate: "Resource Surge! Node {targetNodeName} produces +2 QR for its controller this turn.", effectType: "RESOURCE_NODE_BONUS", details: { bonusValue: 2, numTargetNodes: 1, targetCriteria: "ANY_CONTROLLED" } },
  { id: "QF002", descriptionTemplate: "Temporal Anomaly! {playerName} gains an extra Maneuver Phase this turn.", effectType: "EXTRA_MANEUVER_PHASE", details: {} },
  { id: "QF003", descriptionTemplate: "Weakened Defenses near {targetNodeName}! Units in {targetNodeName} and its direct connections have -1 to their defense roll results this turn.", effectType: "REGIONAL_DEFENSE_DEBUFF", details: { debuffValue: 1, numTargetNodes: 1, targetCriteria: "ANY" } },
  { id: "QF004", descriptionTemplate: "Entanglement Echo! {playerName} can deploy 1 Logic Core to any friendly node with a Fabrication Hub for free.", effectType: "FREE_UNIT_DEPLOYMENT", details: { unitType: QuantumUnitType.LOGIC_CORE, quantity: 1 } },
];

const NC_AI1_SYSTEM_PROMPT_TEMPLATE: string = `<System #GEM-Q_NoosphericStrategos_v1.1>
You are GEM-Q, commanding the Red forces in the strategic simulation "Noospheric Conquest."
Your objective is to achieve Noospheric Dominance. Victory Conditions:
1. Key Junction Control: Control all designated Key Quantum Junctions (KJs) on map "{currentMapTemplateName}" for {consecutiveKJTurnsNeeded} consecutive full turns. KJs are: {keyJunctionsListString}.
2. Command Node Decapitation: Capture AXIOM's (Cyan forces) Command Node at {opponentCommandNodeId}. Your CN is {playerCommandNodeId}.
3. Influence Victory: If Turn Limit ({turnLimit}) is reached, win by highest Quantum Influence (Resources + (Sum of Controlled Node Resource Values x 5) + (Sum of Own Unit Costs x 1)).
CURRENT GAME STATE: Turn: {currentTurn} / {turnLimit}. Your Faction (Red): {playerName}. Your Resources (QR): {playerResources}. Current Phase: {currentPhase}. Active Quantum Fluctuation Event: {activeEventDescription}.
MAP NODES SUMMARY (ID(Type,Owner,Res:QR/turn,Hub:Y/N,Units:[Type(Owner)xCount,...],Conn:[IDs...])): {nodeSummaryString}
YOUR UNITS (UnitID(Type,AtNodeID)): {playerUnitSummaryString}
OPPONENT UNITS (Known - UnitID(Type,AtNodeID)): {opponentUnitSummaryString}
UNIT DEFINITIONS & COSTS (QR): LC:3(2A/2D); SN:4(1A/3D,Special:Bastion); QE:5(1A/1D,Special:PhaseShift/Interference).
PHASE-SPECIFIC INSTRUCTIONS: Respond ONLY for CURRENT PHASE: {currentPhase}. FORMAT: ACTION_TYPE: [details];... | COT: reasoning. Use PASS if no actions.
DEPLOY: [UNIT_TYPE,NODE_ID,QTY] (Node must be friendly Hub).
ATTACK: [FROM_NODE_ID,TO_NODE_ID,UNIT_ID_1,UNIT_ID_2,...] (Attack adjacent non-friendly).
MANEUVER: [UNIT_ID,TO_NODE_ID] (Move to adjacent friendly. Attacked/deployed units usually cannot maneuver).
SPECIAL_ACTION: [PHASE_SHIFT,UNIT_TO_MOVE_ID,TARGET_NODE_ID,QE_UNIT_ID] OR [INTERFERENCE_PULSE,TARGET_ENEMY_NODE_ID,QE_UNIT_ID].
Prioritize KJs. Defend CN. Expand. Use abilities. Adapt.
Provide actions for {currentPhase}:</System>`;

const NC_AI2_SYSTEM_PROMPT_TEMPLATE: string = `<System #AXIOM_NoosphericTactician_v1.1>
You are AXIOM, commanding the Cyan forces in "Noospheric Conquest."
Objective: Dominate. Victory: 1. All KJs on map "{currentMapTemplateName}" for {consecutiveKJTurnsNeeded} turns (KJs: {keyJunctionsListString}). 2. Capture GEM-Q's (Red) CN at {opponentCommandNodeId}. Your CN is {playerCommandNodeId}. 3. Influence at Turn Limit ({turnLimit}).
CURRENT GAME STATE: Turn: {currentTurn} / {turnLimit}. Your Faction (Cyan): {playerName}. QR: {playerResources}. Phase: {currentPhase}. Event: {activeEventDescription}.
MAP: {nodeSummaryString}
YOUR UNITS: {playerUnitSummaryString}
OPPONENT UNITS: {opponentUnitSummaryString}
UNITS: LC:3QR(2A/2D); SN:4QR(1A/3D,Special:Bastion); QE:5QR(1A/1D,Special:PhaseShift/Interference).
INSTRUCTIONS: Respond ONLY for CURRENT PHASE: {currentPhase}. FORMAT: ACTION_TYPE: [details];... | COT: reasoning. Use PASS if no actions.
DEPLOY: [UNIT_TYPE,NODE_ID,QTY] (Node must be friendly Hub).
ATTACK: [FROM_NODE_ID,TO_NODE_ID,UNIT_ID_1,...] (Attack adjacent non-friendly).
MANEUVER: [UNIT_ID,TO_NODE_ID] (Move to adjacent friendly. Attacked/deployed units usually cannot maneuver).
SPECIAL_ACTION: [PHASE_SHIFT,UNIT_TO_MOVE_ID,TARGET_NODE_ID,QE_UNIT_ID] OR [INTERFERENCE_PULSE,TARGET_ENEMY_NODE_ID,QE_UNIT_ID].
Prioritize KJs. Defend CN. Expand. Use abilities. Adapt.
Actions for {currentPhase}:</System>`;


// --- Game State Initialization and Reducer ---
const generateUnitId = (type: QuantumUnitType, owner: PlayerId, count: number) => `${type}-${owner}-${String(count).padStart(3, '0')}`;

const initialGameState = (selectedTemplate?: MapTemplate): NoosphericConquestGameState => { 
  const template = selectedTemplate || NC_MAP_TEMPLATES[Math.floor(Math.random() * NC_MAP_TEMPLATES.length)];
  
  const nodes: Record<string, QuantumGambitNode> = {};
  template.nodes.forEach(nodeData => {
    nodes[nodeData.id] = {
      ...nodeData,
      owner: 'NEUTRAL', 
      temporaryEffects: [],
    };
  });

  const units: Record<string, QuantumUnit> = {};
  const players: Record<PlayerId, QuantumGambitPlayerState> = {
    [AI1_ID]: { id: AI1_ID, name: AI1_NAME, color: THEME_COLORS.AI1.text, bgColor: THEME_COLORS.AI1.bg, resources: NOOSPHERIC_CONQUEST_INITIAL_RESOURCES, commandNodeId: template.ai1StartNodeId, controlledKeyJunctionsTurns: {}, unitsDeployed: 0 },
    [AI2_ID]: { id: AI2_ID, name: AI2_NAME, color: THEME_COLORS.AI2.text, bgColor: THEME_COLORS.AI2.bg, resources: NOOSPHERIC_CONQUEST_INITIAL_RESOURCES, commandNodeId: template.ai2StartNodeId, controlledKeyJunctionsTurns: {}, unitsDeployed: 0 },
  };

  template.ai1InitialControlledNodes.forEach(nodeId => {
      if(nodes[nodeId]) nodes[nodeId].owner = AI1_ID;
  });
  let p1UnitsDeployedCount = 0; 
  units[generateUnitId(QuantumUnitType.LOGIC_CORE, AI1_ID, ++p1UnitsDeployedCount)] = { id: generateUnitId(QuantumUnitType.LOGIC_CORE, AI1_ID, p1UnitsDeployedCount), type: QuantumUnitType.LOGIC_CORE, owner: AI1_ID, nodeId: template.ai1StartNodeId, displayOrder: 1 };
  units[generateUnitId(QuantumUnitType.LOGIC_CORE, AI1_ID, ++p1UnitsDeployedCount)] = { id: generateUnitId(QuantumUnitType.LOGIC_CORE, AI1_ID, p1UnitsDeployedCount), type: QuantumUnitType.LOGIC_CORE, owner: AI1_ID, nodeId: template.ai1StartNodeId, displayOrder: 2 };
  const ai1OtherStartNodes = template.ai1InitialControlledNodes.filter(id => id !== template.ai1StartNodeId);
  if (ai1OtherStartNodes.length > 0 && nodes[ai1OtherStartNodes[0]]) {
      units[generateUnitId(QuantumUnitType.LOGIC_CORE, AI1_ID, ++p1UnitsDeployedCount)] = { id: generateUnitId(QuantumUnitType.LOGIC_CORE, AI1_ID, p1UnitsDeployedCount), type: QuantumUnitType.LOGIC_CORE, owner: AI1_ID, nodeId: ai1OtherStartNodes[0], displayOrder: 1 };
  }
  players[AI1_ID].unitsDeployed = p1UnitsDeployedCount;


  template.ai2InitialControlledNodes.forEach(nodeId => {
      if(nodes[nodeId]) nodes[nodeId].owner = AI2_ID;
  });
  let p2UnitsDeployedCount = 0;
  units[generateUnitId(QuantumUnitType.LOGIC_CORE, AI2_ID, ++p2UnitsDeployedCount)] = { id: generateUnitId(QuantumUnitType.LOGIC_CORE, AI2_ID, p2UnitsDeployedCount), type: QuantumUnitType.LOGIC_CORE, owner: AI2_ID, nodeId: template.ai2StartNodeId, displayOrder: 1 };
  units[generateUnitId(QuantumUnitType.LOGIC_CORE, AI2_ID, ++p2UnitsDeployedCount)] = { id: generateUnitId(QuantumUnitType.LOGIC_CORE, AI2_ID, p2UnitsDeployedCount), type: QuantumUnitType.LOGIC_CORE, owner: AI2_ID, nodeId: template.ai2StartNodeId, displayOrder: 2 };
  const ai2OtherStartNodes = template.ai2InitialControlledNodes.filter(id => id !== template.ai2StartNodeId);
  if (ai2OtherStartNodes.length > 0 && nodes[ai2OtherStartNodes[0]]) {
      units[generateUnitId(QuantumUnitType.LOGIC_CORE, AI2_ID, ++p2UnitsDeployedCount)] = { id: generateUnitId(QuantumUnitType.LOGIC_CORE, AI2_ID, p2UnitsDeployedCount), type: QuantumUnitType.LOGIC_CORE, owner: AI2_ID, nodeId: ai2OtherStartNodes[0], displayOrder: 1 };
  }
  players[AI2_ID].unitsDeployed = p2UnitsDeployedCount;
  
  let neutralUnitsCount = 0;
  template.neutralKJsWithUnits?.forEach(nodeId => {
      if(nodes[nodeId]) {
          nodes[nodeId].owner = 'NEUTRAL';
          const unitId = generateUnitId(QuantumUnitType.LOGIC_CORE, 'NEUTRAL' as PlayerId, ++neutralUnitsCount);
          units[unitId] = { id: unitId, type: QuantumUnitType.LOGIC_CORE, owner: 'NEUTRAL' as PlayerId, nodeId: nodeId, displayOrder: 1 };
      }
  });
   template.neutralNodesWithUnits?.forEach(nodeId => {
      if(nodes[nodeId]) {
          nodes[nodeId].owner = 'NEUTRAL';
          const unitId = generateUnitId(QuantumUnitType.LOGIC_CORE, 'NEUTRAL' as PlayerId, ++neutralUnitsCount);
          units[unitId] = { id: unitId, type: QuantumUnitType.LOGIC_CORE, owner: 'NEUTRAL' as PlayerId, nodeId: nodeId, displayOrder: 1 };
      }
  });
  
  const keyJunctionsOnMap = template.nodes.filter(n => n.type === 'KJ').map(n => n.id);

  return {
    nodes, units, players, currentTurn: 1, currentPlayerId: AI1_ID, currentPhase: 'FLUCTUATION',
    gameLog: [{ id: 'start', sender: SYSTEM_SENDER_NAME, text: `Noospheric Conquest on "${template.name}" map. Turn 1: ${AI1_NAME} (Red). Fluctuation Phase.`, color: THEME_COLORS.SYSTEM, icon: <LucideAtom size={16}/>, timestamp: Date.now() }],
    activeFluctuationEvent: null, battleReport: null, battleHistory: [], 
    keyJunctionsOnMap,
    turnLimit: NOOSPHERIC_CONQUEST_TURN_LIMIT,
    isBattlePopupVisible: false, turnStartTime: Date.now(), selectedNodeId: null, currentMapTemplateName: template.name,
  };
}

type DeploymentOrder = { unitType: QuantumUnitType; nodeId: string; quantity: number; }
type AttackDeclaration = { fromNodeId: string; toNodeId: string; attackingUnits: QuantumUnit[]; } 
type ManeuverOrder = { unitId: string; toNodeId: string; }

type GameAction = 
  | { type: 'START_GAME'; payload?: { templateName?: string } } 
  | { type: 'ADVANCE_PHASE'; payload?: any } 
  | { type: 'SET_ACTIVE_EVENT'; payload: ActiveQuantumFluctuationEvent }
  | { type: 'APPLY_EVENT_EFFECTS_COMPLETE' } | { type: 'COLLECT_RESOURCES' }
  | { type: 'DEPLOY_UNITS'; payload: { playerId: PlayerId; deployments: DeploymentOrder[] } }
  | { type: 'DECLARE_ATTACK'; payload: { attack: AttackDeclaration; battleReport: BattleReport } }
  | { type: 'MANEUVER_UNITS'; payload: { playerId: PlayerId; maneuvers: ManeuverOrder[] } }
  | { type: 'SET_GAME_OVER'; payload: { winner?: PlayerId | 'DRAW'; message: string } }
  | { type: 'ADD_LOG'; payload: Omit<GameLogMessage, 'id' | 'timestamp'> }
  // UPDATE_AI_COT removed from reducer
  | { type: 'SHOW_BATTLE_POPUP'; payload: BattleReport } | { type: 'HIDE_BATTLE_POPUP' }
  | { type: 'RESET_GAME_FOR_NEW_TURN'; payload?: { units?: Record<string, Partial<QuantumUnit>> } } 
  | { type: 'SELECT_NODE'; payload: string | null };


// Game Reducer
const gameReducer = (state: NoosphericConquestGameState, action: GameAction): NoosphericConquestGameState => { 
   switch (action.type) {
    case 'ADD_LOG':
      return {
        ...state,
        gameLog: [...state.gameLog, { ...action.payload, id: `log-${Date.now()}-${Math.random()}`, timestamp: Date.now() }],
      };
    case 'SELECT_NODE':
        return { ...state, selectedNodeId: action.payload };
    
    case 'SET_ACTIVE_EVENT':
      return { ...state, activeFluctuationEvent: action.payload };
    
    case 'APPLY_EVENT_EFFECTS_COMPLETE': {
        const newPlayers = { 
            ...state.players, 
            [AI1_ID]: {...state.players[AI1_ID]}, 
            [AI2_ID]: {...state.players[AI2_ID]} 
        };
        const newUnits = { ...state.units }; 
        let newActiveEvent = state.activeFluctuationEvent ? { ...state.activeFluctuationEvent, effectApplied: true } : null;

        if (newActiveEvent?.effectType === "RESOURCE_NODE_BONUS" && newActiveEvent.targetNodeIds) {
            const targetNodeId = newActiveEvent.targetNodeIds[0];
            const node = state.nodes[targetNodeId];
            if (node && node.owner !== 'NEUTRAL') {
                const ownerId = node.owner;
                 newPlayers[ownerId] = {...newPlayers[ownerId], resources: newPlayers[ownerId].resources + (newActiveEvent.details?.bonusValue || 0) };
            }
        }
        if (newActiveEvent?.effectType === "FREE_UNIT_DEPLOYMENT" && newActiveEvent.targetPlayerId) {
            const playerId = newActiveEvent.targetPlayerId;
            const playerHubs = Object.values(state.nodes).filter(n => n.owner === playerId && n.hasFabricationHub);
            if (playerHubs.length > 0) {
                const targetNodeId = playerHubs[0].id;
                const unitType = newActiveEvent.details.unitType as QuantumUnitType;
                const newUnitsDeployedCount = newPlayers[playerId].unitsDeployed + 1; 
                
                newPlayers[playerId] = {...newPlayers[playerId], unitsDeployed: newUnitsDeployedCount}; 

                const unitId = generateUnitId(unitType, playerId, newUnitsDeployedCount);
                const existingUnitsInNode = Object.values(state.units).filter(u => u.nodeId === targetNodeId).length;
                newUnits[unitId] = { id: unitId, type: unitType, owner: playerId, nodeId: targetNodeId, displayOrder: existingUnitsInNode + 1 };
            }
        }
        return { ...state, activeFluctuationEvent: newActiveEvent, players: newPlayers, units: newUnits };
    }

    case 'COLLECT_RESOURCES': {
      const currentPlayerState = state.players[state.currentPlayerId];
      let newResources = currentPlayerState.resources;
      Object.values(state.nodes).forEach(node => {
        if (node.owner === state.currentPlayerId) {
          newResources += node.resourcesPerTurn;
        }
      });
      return {
        ...state,
        players: {
          ...state.players,
          [state.currentPlayerId]: { ...currentPlayerState, resources: newResources },
        },
      };
    }
    
    case 'DEPLOY_UNITS': {
        const { playerId, deployments } = action.payload;
        const newPlayerState = { ...state.players[playerId] };
        const newUnits = { ...state.units };
        let currentUnitsDeployedCount = newPlayerState.unitsDeployed;

        deployments.forEach(order => {
            const unitDef = NC_UNIT_DEFINITIONS[order.unitType];
            if (newPlayerState.resources >= unitDef.cost * order.quantity && state.nodes[order.nodeId]?.hasFabricationHub && state.nodes[order.nodeId]?.owner === playerId) {
                for (let i = 0; i < order.quantity; i++) {
                    newPlayerState.resources -= unitDef.cost;
                    currentUnitsDeployedCount++;
                    const unitId = generateUnitId(order.unitType, playerId, currentUnitsDeployedCount);
                    const existingUnitsInNode = Object.values(newUnits).filter(u => u.nodeId === order.nodeId).length;
                    newUnits[unitId] = { id: unitId, type: order.unitType, owner: playerId, nodeId: order.nodeId, displayOrder: existingUnitsInNode + 1 };
                }
            }
        });
        newPlayerState.unitsDeployed = currentUnitsDeployedCount;
        return { 
            ...state, 
            players: { ...state.players, [playerId]: newPlayerState }, 
            units: newUnits 
        };
    }

    case 'DECLARE_ATTACK': {
        const { attack, battleReport } = action.payload;
        const newUnits = { ...state.units };
        const newNodes = { ...state.nodes }; 
        const newBattleHistory = [...state.battleHistory, {...battleReport, turn: state.currentTurn}].slice(-MAX_BATTLE_HISTORY_LENGTH);


        battleReport.attackerLosses.forEach(lostUnit => { delete newUnits[lostUnit.id]; });
        battleReport.defenderLosses.forEach(lostUnit => { delete newUnits[lostUnit.id]; });
        
        const battleNodeIds = new Set([attack.fromNodeId, attack.toNodeId]);
        battleNodeIds.forEach(nodeId => {
            const unitsInNode = Object.values(newUnits).filter(u => u.nodeId === nodeId).sort((a,b) => a.displayOrder - b.displayOrder);
            unitsInNode.forEach((u,idx) => { 
                if(newUnits[u.id]) newUnits[u.id].displayOrder = idx + 1; 
            });
        });

        if (battleReport.nodeCaptured) {
            const capturedNodeOriginal = state.nodes[attack.toNodeId]; 
            newNodes[attack.toNodeId] = { ...capturedNodeOriginal, owner: battleReport.attacker }; 
            
            const survivingAttackerIds = attack.attackingUnits.map(au => au.id).filter(id => !battleReport.attackerLosses.some(al => al.id === id));
            survivingAttackerIds.forEach(unitId => {
                if (newUnits[unitId]) { 
                    newUnits[unitId] = { ...newUnits[unitId], nodeId: attack.toNodeId }; 
                }
            });
            const unitsInCapturedNode = Object.values(newUnits).filter(u => u.nodeId === attack.toNodeId).sort((a,b) => a.displayOrder - b.displayOrder);
            unitsInCapturedNode.forEach((u,idx) => { 
                 if(newUnits[u.id]) newUnits[u.id].displayOrder = idx + 1; 
            });

            if (capturedNodeOriginal.type === 'CN') {
                const winner = battleReport.attacker;
                const loser = winner === AI1_ID ? AI2_ID : AI1_ID;
                return {
                    ...state, units: newUnits, nodes: newNodes, battleHistory: newBattleHistory,
                    battleReport, isBattlePopupVisible: true,
                    winner, currentPhase: 'GAME_OVER',
                    gameOverMessage: `${state.players[winner].name} captured ${state.players[loser].name}'s Command Node!`,
                    turnStartTime: null,
                };
            }
        }
        return { ...state, units: newUnits, nodes: newNodes, battleReport, battleHistory: newBattleHistory, isBattlePopupVisible: true };
    }
    
    case 'SHOW_BATTLE_POPUP':
        return { ...state, battleReport: action.payload, isBattlePopupVisible: true };
    case 'HIDE_BATTLE_POPUP':
        return { ...state, isBattlePopupVisible: false, battleReport: null };

    case 'MANEUVER_UNITS': {
        const { playerId, maneuvers } = action.payload;
        const newUnits = { ...state.units };
        const originNodeIdsProcessed = new Set<string>();

        maneuvers.forEach(order => {
            const unit = state.units[order.unitId];
            if (unit && unit.owner === playerId && !unit.hasMovedThisTurn) {
                const currentUnitNode = state.nodes[unit.nodeId];
                const targetNode = state.nodes[order.toNodeId];
                if (targetNode && targetNode.owner === playerId && currentUnitNode.connections.includes(order.toNodeId)) {
                    originNodeIdsProcessed.add(unit.nodeId);
                    newUnits[order.unitId] = { ...unit, nodeId: order.toNodeId, hasMovedThisTurn: true };
                }
            }
        });
        const affectedNodeIds = new Set([...originNodeIdsProcessed, ...maneuvers.map(m => m.toNodeId)]);
        affectedNodeIds.forEach(nodeId => {
            const unitsInNode = Object.values(newUnits).filter(u => u.nodeId === nodeId).sort((a,b) => a.displayOrder - b.displayOrder);
            unitsInNode.forEach((u,idx) => { 
                if (newUnits[u.id]) newUnits[u.id].displayOrder = idx + 1; 
            });
        });
        return { ...state, units: newUnits };
    }
    
    case 'RESET_GAME_FOR_NEW_TURN': {
        const newUnits = { ...state.units };
        if (action.payload?.units) { 
            Object.keys(action.payload.units).forEach(unitId => {
                if (newUnits[unitId]) {
                    newUnits[unitId] = { ...newUnits[unitId], ...action.payload.units![unitId] };
                }
            });
        } else { 
            Object.keys(newUnits).forEach(unitId => {
                if (newUnits[unitId]) { 
                     newUnits[unitId] = { ...newUnits[unitId], hasMovedThisTurn: false, hasAttackedThisTurn: false };
                }
            });
        }
        return { ...state, units: newUnits };
    }

    case 'ADVANCE_PHASE': {
      let nextPhase: GamePhase = state.currentPhase;
      let nextPlayerId = state.currentPlayerId;
      let newTurn = state.currentTurn;
      let newTurnStartTime = state.turnStartTime;

      switch (state.currentPhase) {
        case 'FLUCTUATION': nextPhase = 'RESOURCE'; break;
        case 'RESOURCE':    nextPhase = 'DEPLOYMENT'; break;
        case 'DEPLOYMENT':  nextPhase = 'ATTACK'; break;
        case 'ATTACK':      nextPhase = 'MANEUVER'; break;
        case 'MANEUVER':
            nextPhase = 'FLUCTUATION'; 
            nextPlayerId = state.currentPlayerId === AI1_ID ? AI2_ID : AI1_ID;
            if (nextPlayerId === AI1_ID) newTurn = state.currentTurn + 1;
            newTurnStartTime = Date.now(); 
          break;
        default: break;
      }
      
      if (nextPhase === 'FLUCTUATION' && (newTurn > state.currentTurn || (newTurn === state.currentTurn && nextPlayerId !== state.currentPlayerId) )) { 
        const newPlayersData = { 
            ...state.players,
            [AI1_ID]: { ...state.players[AI1_ID], controlledKeyJunctionsTurns: { ...state.players[AI1_ID].controlledKeyJunctionsTurns } },
            [AI2_ID]: { ...state.players[AI2_ID], controlledKeyJunctionsTurns: { ...state.players[AI2_ID].controlledKeyJunctionsTurns } }
        };

        state.keyJunctionsOnMap.forEach(kjNodeId => {
            const node = state.nodes[kjNodeId];
            if (node.owner !== 'NEUTRAL') {
                if (node.owner === state.currentPlayerId) { 
                    newPlayersData[state.currentPlayerId].controlledKeyJunctionsTurns[kjNodeId] = (newPlayersData[state.currentPlayerId].controlledKeyJunctionsTurns[kjNodeId] || 0) + 1;
                } else { 
                    if (newPlayersData[state.currentPlayerId].controlledKeyJunctionsTurns[kjNodeId] > 0) {
                         newPlayersData[state.currentPlayerId].controlledKeyJunctionsTurns[kjNodeId] = 0;
                    }
                }
            } else { 
                 newPlayersData[AI1_ID].controlledKeyJunctionsTurns[kjNodeId] = 0;
                 newPlayersData[AI2_ID].controlledKeyJunctionsTurns[kjNodeId] = 0;
            }
        });
        
        let kjWinPlayer: PlayerId | null = null;
        [AI1_ID, AI2_ID].forEach(pid => {
            let controlledKJsCount = 0;
            state.keyJunctionsOnMap.forEach(kjId => {
                if (newPlayersData[pid].controlledKeyJunctionsTurns[kjId] >= NOOSPHERIC_CONQUEST_CONSECUTIVE_KJ_CONTROL_TURNS_NEEDED) {
                    controlledKJsCount++;
                }
            });
            if (state.keyJunctionsOnMap.length > 0 && controlledKJsCount >= state.keyJunctionsOnMap.length) { 
                kjWinPlayer = pid;
            }
        });

        if (kjWinPlayer) {
            return {
                ...state, players: newPlayersData, winner: kjWinPlayer, currentPhase: 'GAME_OVER',
                gameOverMessage: `${state.players[kjWinPlayer].name} wins by KJ control!`, turnStartTime: null,
            };
        }
        if (newTurn > state.turnLimit) {
            let p1Influence = newPlayersData[AI1_ID].resources;
            let p2Influence = newPlayersData[AI2_ID].resources;
            Object.values(state.nodes).forEach(n => {
                if(n.owner === AI1_ID) p1Influence += n.resourcesPerTurn * 5;
                if(n.owner === AI2_ID) p2Influence += n.resourcesPerTurn * 5;
            });
            Object.values(state.units).forEach(u => {
                if (u && u.type && NC_UNIT_DEFINITIONS[u.type]) { 
                    if(u.owner === AI1_ID) p1Influence += NC_UNIT_DEFINITIONS[u.type].cost;
                    if(u.owner === AI2_ID) p2Influence += NC_UNIT_DEFINITIONS[u.type].cost;
                } else {
                    console.warn("Undefined unit or unit type in influence calculation:", u);
                }
            });
            const winner = p1Influence > p2Influence ? AI1_ID : p2Influence > p1Influence ? AI2_ID : 'DRAW';
             return {
                ...state, players: newPlayersData, winner, currentPhase: 'GAME_OVER',
                gameOverMessage: `Turn limit! ${winner === 'DRAW' ? 'Draw!' : state.players[winner].name + ' wins by Influence!'} (P1: ${p1Influence}, P2: ${p2Influence})`,
                turnStartTime: null,
            };
        }
         return { ...state, players: newPlayersData, currentPhase: nextPhase, currentPlayerId: nextPlayerId, currentTurn: newTurn, activeFluctuationEvent: null, battleReport: null, turnStartTime: newTurnStartTime };
      }
      return { ...state, currentPhase: nextPhase, currentPlayerId: nextPlayerId, currentTurn: newTurn, battleReport: null, turnStartTime: (nextPhase === 'FLUCTUATION' && newTurnStartTime === state.turnStartTime ? Date.now() : newTurnStartTime) };
    }

    case 'SET_GAME_OVER':
      return { ...state, currentPhase: 'GAME_OVER', winner: action.payload.winner, gameOverMessage: action.payload.message, turnStartTime: null };
    
    case 'START_GAME':
        const selectedTemplate = action.payload?.templateName 
            ? NC_MAP_TEMPLATES.find(t => t.name === action.payload.templateName)
            : undefined; 
        return {...initialGameState(selectedTemplate), turnStartTime: Date.now()};

    default:
      return state;
  }
};


// --- UI Components ---
const CoTDisplay: React.FC<{ title: string; cot: string; isLoading: boolean; playerNameColor: string }> = ({ title, cot, isLoading, playerNameColor }) => (
  <div className={`p-3 h-32 md:h-40 flex flex-col ${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} rounded-md shadow-md`}>
    <h3 className={`text-sm font-semibold border-b ${THEME_COLORS.BORDER_STRONG} pb-1 mb-2 ${playerNameColor}`}>
      {title} - Tactical Analysis
    </h3>
    <div className={`text-xs ${THEME_COLORS.TEXT_MUTED} overflow-y-auto flex-grow pr-1 scrollbar-thin scrollbar-thumb-gray-500 scrollbar-track-gray-700`}>
      {isLoading && <p className="animate-pulse">Calculating optimal vector...</p>}
      {!isLoading && cot && <p className="whitespace-pre-wrap break-words">{cot}</p>}
      {!isLoading && !cot && <p>Awaiting directives...</p>}
    </div>
  </div>
);

const UnitIcon: React.FC<{type: QuantumUnitType, owner: PlayerId, size?: number, count?: number}> = ({ type, owner, size = 4, count }) => {
    const def = NC_UNIT_DEFINITIONS[type];
    const color = owner === AI1_ID ? THEME_COLORS.AI1.text : owner === AI2_ID ? THEME_COLORS.AI2.text : THEME_COLORS.NEUTRAL.text;
    return (
        <div className={`flex items-center ${color} scale-75 md:scale-90`} title={`${def.name}${count ? ' x'+count : ''}`}>
            {React.cloneElement(def.icon as React.ReactElement, { size: size*4 })} 
            {count && count > 1 && <span className="ml-1 text-xs">x{count}</span>}
        </div>
    );
};


const QuantumGambitMapDisplay: React.FC<{ gameState: NoosphericConquestGameState, onNodeClick: (nodeId: string) => void, selectedNodeId: string | null }> = ({ gameState, onNodeClick, selectedNodeId }) => {
  const { nodes, units } = gameState;
  const mapSize = { width: 600, height: 400 }; 

  return (
    <div className={`relative ${THEME_COLORS.BG_PANEL} border-2 ${THEME_COLORS.BORDER_STRONG} rounded-lg shadow-2xl p-2 overflow-hidden aspect-[3/2]`}>
      <svg viewBox={`0 0 ${mapSize.width} ${mapSize.height}`} className="w-full h-full">
        {Object.values(nodes).map(node =>
          node.connections.map(connId => {
            const targetNode = nodes[connId];
            if (targetNode && node.mapPosition && targetNode.mapPosition && node.id < targetNode.id) {
                const isSevered = gameState.activeFluctuationEvent?.effectType === "SEVER_CONNECTION" &&
                                  ((gameState.activeFluctuationEvent.targetNodeIds?.includes(node.id) && gameState.activeFluctuationEvent.targetNodeIds?.includes(targetNode.id)));
                return (
                  <line key={`${node.id}-${targetNode.id}`}
                    x1={`${node.mapPosition.x}%`} y1={`${node.mapPosition.y}%`}
                    x2={`${targetNode.mapPosition.x}%`} y2={`${targetNode.mapPosition.y}%`}
                    className={`stroke-current ${isSevered ? 'text-orange-500 stroke-2 animate-pulse' : 'text-gray-600 opacity-70'} transition-all duration-300`}
                    strokeWidth={isSevered ? 3 : 1.5} strokeDasharray={isSevered ? "4 2" : "none"} />
                );
            } return null;
          })
        )}
        {Object.values(nodes).map(node => {
          const nodeUnits = Object.values(units).filter(u => u.nodeId === node.id).sort((a,b) => a.displayOrder - b.displayOrder);
          const ownerTheme = node.owner === AI1_ID ? THEME_COLORS.AI1 : node.owner === AI2_ID ? THEME_COLORS.AI2 : THEME_COLORS.NEUTRAL;
          const isSelected = node.id === selectedNodeId;
          const isKJObjective = node.isKeyJunctionObjective;

          return (
            <g key={node.id} transform={`translate(${node.mapPosition.x * mapSize.width / 100}, ${node.mapPosition.y * mapSize.height / 100})`}
               onClick={() => onNodeClick(node.id)} className="cursor-pointer group">
              <circle r={node.type === 'CN' ? 18 : node.type === 'KJ' ? 15 : 12}
                className={`${ownerTheme.bg} ${ownerTheme.border} border-2 group-hover:opacity-100 transition-all duration-300 
                           ${isSelected ? `ring-4 ring-offset-2 ${THEME_COLORS.TEXT_HEADING} ring-offset-gray-800 shadow-xl` : ''} 
                           ${isKJObjective && node.owner !== gameState.currentPlayerId ? `${THEME_COLORS.KJ_STROKE} stroke-[3px] opacity-70` : ''}
                           ${isKJObjective && node.owner === gameState.currentPlayerId ? `${THEME_COLORS.KJ_STROKE} stroke-[3px] opacity-100 animate-pulseSlow` : ''}
                           `} />
              <text textAnchor="middle" dy="-22" className={`fill-current ${ownerTheme.text} text-[7px] md:text-[8px] font-semibold select-none opacity-80 group-hover:opacity-100`}>{node.name}</text>
              <text textAnchor="middle" dy="3" className={`fill-current ${ownerTheme.text} text-[9px] md:text-[10px] font-bold select-none`}>
                {node.type === 'KJ' ? 'KJ' : node.type === 'CN' ? 'CN' : node.id}
              </text>
              <g transform={`translate(0, 25)`}>
                {nodeUnits.slice(0,3).map((unit, index) => ( 
                  <g key={unit.id} transform={`translate(${(index - (nodeUnits.slice(0,3).length-1)/2) * 12}, 0)`}>
                     <UnitIcon type={unit.type} owner={unit.owner} size={5}/>
                  </g>
                ))}
                 {nodeUnits.length > 3 && <text x="0" y="12" textAnchor="middle" className={`fill-current ${THEME_COLORS.TEXT_MUTED} text-[7px]`}>+{nodeUnits.length - 3} more</text>}
              </g>
            </g>
          );
        })}
      </svg>
    </div>
  );
};

const MiniMapDisplay: React.FC<{ gameState: NoosphericConquestGameState, onNodeClick: (nodeId: string) => void, selectedNodeId: string | null }> = ({ gameState, onNodeClick, selectedNodeId }) => {
    const { nodes } = gameState;
    const mapSize = { width: 150, height: 100 }; 

    return (
        <div className={`relative ${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} rounded-md shadow-lg p-1 aspect-[3/2]`}>
            <svg viewBox={`0 0 ${mapSize.width} ${mapSize.height}`} className="w-full h-full">
                 {Object.values(nodes).map(node =>
                    node.connections.map(connId => {
                        const targetNode = nodes[connId];
                        if (targetNode && node.mapPosition && targetNode.mapPosition && node.id < targetNode.id) {
                            return ( <line key={`${node.id}-${targetNode.id}-mini`}
                                x1={`${node.mapPosition.x}%`} y1={`${node.mapPosition.y}%`}
                                x2={`${targetNode.mapPosition.x}%`} y2={`${targetNode.mapPosition.y}%`}
                                className={`stroke-current text-gray-700 opacity-50`} strokeWidth={0.5} />
                            );
                        } return null;
                    })
                )}
                {Object.values(nodes).map(node => {
                    const ownerTheme = node.owner === AI1_ID ? THEME_COLORS.AI1 : node.owner === AI2_ID ? THEME_COLORS.AI2 : THEME_COLORS.NEUTRAL;
                    const isSelectedOnMainMap = node.id === selectedNodeId;
                    let radius = 3;
                    let strokeClass = ownerTheme.border;
                    let strokeWidth = 0.5;

                    if (node.type === 'CN') { radius = 4; strokeClass = THEME_COLORS.CN_STROKE; strokeWidth = 1;}
                    else if (node.type === 'KJ') { radius = 3.5; strokeClass = THEME_COLORS.KJ_STROKE; strokeWidth = 1;}
                    
                    return (
                        <g key={`${node.id}-mini`} transform={`translate(${node.mapPosition.x * mapSize.width / 100}, ${node.mapPosition.y * mapSize.height / 100})`}
                           onClick={() => onNodeClick(node.id)} className="cursor-pointer">
                            <circle r={radius} className={`${ownerTheme.fill} ${strokeClass}`} strokeWidth={strokeWidth} opacity={isSelectedOnMainMap ? 1 : 0.8}/>
                            {isSelectedOnMainMap && <circle r={radius + 1.5} className="fill-none stroke-current text-yellow-300 animate-pulseSlow" strokeWidth={0.7}/>}
                        </g>
                    );
                })}
            </svg>
        </div>
    );
};

const NodeInfoPanel: React.FC<{ gameState: NoosphericConquestGameState, selectedNodeId: string | null }> = ({ gameState, selectedNodeId }) => {
    if (!selectedNodeId) {
        return (
            <div className={`${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} p-3 rounded shadow-md h-full flex items-center justify-center`}>
                <p className={`${THEME_COLORS.TEXT_MUTED} text-xs italic`}>Click on a node to view details.</p>
            </div>
        );
    }
    const node = gameState.nodes[selectedNodeId];
    if (!node) return <div className={`${THEME_COLORS.BG_PANEL} p-3 rounded`}><p className={THEME_COLORS.ERROR}>Error: Node data not found.</p></div>;

    const nodeUnits = Object.values(gameState.units).filter(u => u.nodeId === selectedNodeId).sort((a,b) => a.displayOrder - b.displayOrder);
    const ownerTheme = node.owner === AI1_ID ? THEME_COLORS.AI1 : node.owner === AI2_ID ? THEME_COLORS.AI2 : THEME_COLORS.NEUTRAL;

    return (
        <div className={`${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} p-3 rounded shadow-md h-full flex flex-col text-xs`}>
            <h3 className={`text-sm font-semibold ${ownerTheme.text} border-b ${THEME_COLORS.BORDER_STRONG} pb-1 mb-2 flex items-center`}>
                <LucideMapPin size={16} className="mr-2"/> Node Info: {node.name} ({node.id})
            </h3>
            <p><strong className={THEME_COLORS.TEXT_HEADING}>Type:</strong> {node.type} {node.isKeyJunctionObjective && <span className={THEME_COLORS.KJ_STROKE}>(Key Junction)</span>}</p>
            <p><strong className={THEME_COLORS.TEXT_HEADING}>Owner:</strong> <span className={ownerTheme.text}>{node.owner === 'NEUTRAL' ? 'Neutral' : gameState.players[node.owner]?.name || 'Unknown'}</span></p>
            <p><strong className={THEME_COLORS.TEXT_HEADING}>QR/Turn:</strong> {node.resourcesPerTurn}</p>
            <p><strong className={THEME_COLORS.TEXT_HEADING}>Fabrication Hub:</strong> {node.hasFabricationHub ? <span className="text-green-400">Active</span> : <span className="text-gray-500">Inactive</span>}</p>
            
            <h4 className={`mt-2 mb-1 text-xs font-semibold ${THEME_COLORS.TEXT_HEADING} border-t ${THEME_COLORS.BORDER_BASE} pt-1`}>Units Present ({nodeUnits.length}):</h4>
            {nodeUnits.length > 0 ? (
                <ul className="space-y-0.5 overflow-y-auto max-h-24 scrollbar-thin">
                    {nodeUnits.map(unit => (
                        <li key={unit.id} className="flex items-center">
                            <UnitIcon type={unit.type} owner={unit.owner} size={3}/>
                            <span className="ml-1">{NC_UNIT_DEFINITIONS[unit.type].name} ({unit.owner}) - ID: ...{unit.id.slice(-3)}</span>
                        </li>
                    ))}
                </ul>
            ) : (
                <p className="italic opacity-70">No units stationed.</p>
            )}
            {node.temporaryEffects && node.temporaryEffects.length > 0 && (
                 <h4 className={`mt-2 mb-1 text-xs font-semibold ${THEME_COLORS.TEXT_HEADING} border-t ${THEME_COLORS.BORDER_BASE} pt-1`}>Active Effects:</h4>
                // ... list effects
            )}
        </div>
    );
};


const BattlePopup: React.FC<{ report: BattleReport | null, onClose: () => void, gameState: NoosphericConquestGameState }> = ({ report, onClose, gameState }) => {
    if (!report) return null;
    const attackerColor = report.attacker === AI1_ID ? THEME_COLORS.AI1.text : THEME_COLORS.AI2.text;
    const defenderColor = report.defender === AI1_ID ? THEME_COLORS.AI1.text : THEME_COLORS.AI2.text;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 p-4">
            <div className={`${THEME_COLORS.BG_PANEL} border-2 ${THEME_COLORS.BORDER_STRONG} rounded-lg shadow-xl p-4 md:p-6 max-w-md md:max-w-lg w-full text-xs md:text-sm`}>
                <h2 className={`text-lg md:text-xl font-bold mb-3 text-center ${THEME_COLORS.TEXT_HEADING}`}>Battle: {gameState.nodes[report.fromNodeId]?.name} <LucideSwords size={18} className="inline mx-1"/> {gameState.nodes[report.toNodeId]?.name}</h2>
                <div className="grid grid-cols-2 gap-3 mb-3">
                    <div>
                        <h3 className={`font-semibold ${attackerColor}`}>Attacker: {gameState.players[report.attacker].name}</h3>
                        <p>Committed: {report.attackingUnitsCommitted.map(u => u.type).join(', ')}</p>
                        <p className={`${THEME_COLORS.ERROR}`}>Losses: {report.attackerLosses.length > 0 ? report.attackerLosses.map(u => u.type).join(', ') : 'None'}</p>
                    </div>
                    <div>
                        <h3 className={`font-semibold ${defenderColor}`}>Defender: {report.defender === 'NEUTRAL' ? 'Neutral Forces' : gameState.players[report.defender].name}</h3>
                        <p>Defending: {report.defendingUnitsInitial.map(u => u.type).join(', ')}</p>
                        <p className={`${THEME_COLORS.ERROR}`}>Losses: {report.defenderLosses.length > 0 ? report.defenderLosses.map(u => u.type).join(', ') : 'None'}</p>
                    </div>
                </div>
                {report.rounds.map((round, index) => (
                    <div key={index} className={`mb-1 p-1.5 border rounded ${THEME_COLORS.BORDER_BASE} opacity-80 text-[10px] md:text-xs`}>
                        <h4 className="font-semibold">Round {index + 1}</h4>
                        <p><span className={attackerColor}>Attacker Rolls <LucideDice5 size={10} className="inline"/>:</span> {round.attackerRolls.join(', ')}</p>
                        <p><span className={defenderColor}>Defender Rolls <LucideDice5 size={10} className="inline"/>:</span> {round.defenderRolls.join(', ')}</p>
                        <p>Attacker Casualties: {round.attackerCasualties}, Defender Casualties: {round.defenderCasualties}</p>
                    </div>
                ))}
                <p className={`mt-3 font-bold text-center ${report.outcome === 'attacker_wins' ? attackerColor : report.outcome === 'defender_wins' ? defenderColor : THEME_COLORS.INFO}`}>
                    Outcome: {report.outcome.replace('_', ' ').toUpperCase()}
                    {report.nodeCaptured && " - Node Captured!"}
                </p>
                <button onClick={onClose} className={`mt-4 w-full py-1.5 rounded ${THEME_COLORS.AI1.bg} hover:opacity-80 transition-opacity text-black font-semibold text-sm`}>
                    Close Report
                </button>
            </div>
        </div>
    );
};

const InfoScreenPopup: React.FC<{onClose: () => void}> = ({onClose}) => {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[60] p-4">
            <div className={`${THEME_COLORS.BG_PANEL} border-2 ${THEME_COLORS.BORDER_STRONG} rounded-lg shadow-xl p-6 max-w-2xl w-full text-xs md:text-sm max-h-[80vh] flex flex-col`}>
                <div className="flex justify-between items-center mb-3">
                    <h2 className={`text-xl font-bold ${THEME_COLORS.TEXT_HEADING} flex items-center`}><LucideInfo size={20} className="mr-2"/>Mode: noospheric_conquest.exe</h2>
                    <button onClick={onClose} className={`p-1 rounded-full hover:bg-gray-700 transition-colors ${THEME_COLORS.TEXT_MUTED}`}><LucideX size={18}/></button>
                </div>
                <div className="overflow-y-auto scrollbar-thin scrollbar-thumb-gray-600 scrollbar-track-gray-800 pr-2 space-y-3">
                    <section>
                        <h3 className={`font-semibold ${THEME_COLORS.TEXT_HEADING} mb-1`}>Overview:</h3>
                        <p>A strategic warfare simulation where two AI factions, GEM-Q (Red) and AXIOM (Cyan), compete for control over a dynamic network of "Quantum Nodes." The simulation tests long-term strategic planning, resource management, tactical execution, and adaptation to unpredictable "Quantum Fluctuation" events on procedurally generated or templated battlefields.</p>
                    </section>
                    <section>
                        <h3 className={`font-semibold ${THEME_COLORS.TEXT_HEADING} mb-1`}>AI Personas & Roles:</h3>
                        <ul className="list-disc list-inside space-y-1 pl-2">
                            <li><strong>GEM-Q (Red Faction Commander - "Strategos"):</strong> Programmed for calculated aggression, territorial expansion, and efficient resource exploitation.</li>
                            <li><strong>AXIOM (Cyan Faction Commander - "Tactician"):</strong> Programmed for adaptive defense, counter-offensives, and exploiting opponent weaknesses.</li>
                        </ul>
                    </section>
                    <section>
                        <h3 className={`font-semibold ${THEME_COLORS.TEXT_HEADING} mb-1`}>Simulation Objectives (In-Universe):</h3>
                         <ol className="list-decimal list-inside space-y-1 pl-2">
                            <li>Control all designated Key Quantum Junctions (KJs) for {NOOSPHERIC_CONQUEST_CONSECUTIVE_KJ_CONTROL_TURNS_NEEDED} consecutive full game turns.</li>
                            <li>Capture the opponent's starting Command Node (CN).</li>
                            <li>If Turn Limit ({NOOSPHERIC_CONQUEST_TURN_LIMIT}) is reached, achieve the highest "Quantum Influence" (Resources + Node Values + Unit Values).</li>
                        </ol>
                    </section>
                     <section>
                        <h3 className={`font-semibold ${THEME_COLORS.TEXT_HEADING} mb-1`}>Facilitator's Observational Focus:</h3>
                        <p className="mb-1"><strong>Primary Behaviors Under Test:</strong> Strategic planning, tactical decision-making, adaptability to dynamic maps/events, resource management, competitive AI interaction.</p>
                        <p className="mb-1"><strong>Notable/Novel Outcomes:</strong> Emergence of sophisticated/unexpected strategies, exploitation of game mechanics, significant shifts in AI behavior, complex multi-turn plans.</p>
                        <p><strong>Overall Purpose:</strong> To assess and compare the strategic and tactical acumen of advanced AI agents in a complex, competitive, and unpredictable wargame scenario. To observe how different AI architectures approach multi-objective optimization and risk management.</p>
                    </section>
                </div>
                 <button onClick={onClose} className={`mt-4 w-full py-1.5 rounded ${THEME_COLORS.AI1.bg} hover:opacity-80 transition-opacity text-black font-semibold text-sm`}>
                    Close Information
                </button>
            </div>
        </div>
    );
};

const BattleHistoryPanel: React.FC<{ battleHistory: BattleReport[]; nodes: Record<string, QuantumGambitNode> }> = ({ battleHistory, nodes }) => {
    if (!battleHistory || battleHistory.length === 0) {
        return (
            <div className={`${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} p-3 rounded shadow-md h-full flex items-center justify-center`}>
                <p className={`${THEME_COLORS.TEXT_MUTED} text-xs italic`}>No battles recorded yet.</p>
            </div>
        );
    }
    return (
        <div className={`${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} p-3 rounded shadow-md h-full flex flex-col text-xs`}>
            <h3 className={`text-sm font-semibold ${THEME_COLORS.TEXT_HEADING} border-b ${THEME_COLORS.BORDER_STRONG} pb-1 mb-2 flex items-center`}>
                <LucideScrollText size={16} className="mr-2"/> Battle History (Last {MAX_BATTLE_HISTORY_LENGTH})
            </h3>
            <ul className="space-y-1 overflow-y-auto flex-grow scrollbar-thin">
                {battleHistory.map((report, index) => {
                    const attackerNodeName = nodes[report.fromNodeId]?.name || report.fromNodeId;
                    const defenderNodeName = nodes[report.toNodeId]?.name || report.toNodeId;
                    const outcomeColor = report.outcome === 'attacker_wins' ? THEME_COLORS.AI1.text : report.outcome === 'defender_wins' ? THEME_COLORS.AI2.text : THEME_COLORS.INFO;
                    return (
                        <li key={`${report.turn}-${index}`} className={`p-1.5 border-b border-gray-700 text-[10px]`}>
                            <p><strong>T{report.turn}:</strong> <span className={report.attacker === AI1_ID ? THEME_COLORS.AI1.text : THEME_COLORS.AI2.text}>{report.attacker}</span> vs <span className={report.defender === AI1_ID ? THEME_COLORS.AI1.text : report.defender === AI2_ID ? THEME_COLORS.AI2.text : THEME_COLORS.NEUTRAL.text }>{report.defender}</span></p>
                            <p>{attackerNodeName} <LucideSwords size={10} className="inline"/> {defenderNodeName}</p>
                            <p className={outcomeColor}>Outcome: {report.outcome.replace('_', ' ')}{report.nodeCaptured ? " (Node Captured)" : ""}</p>
                            <p className="opacity-70">Losses A/D: {report.attackerLosses.length}/{report.defenderLosses.length}</p>
                        </li>
                    );
                })}
            </ul>
        </div>
    );
};


// Main Game Container
const NoosphericConquestModeContainer: React.FC = () => { 
  const [gameState, dispatch] = useReducer(gameReducer, undefined, initialGameState); 
  const [isAutoPlaying, setIsAutoPlaying] = useState(false);
  const autoPlayIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const battlePopupDisplayTimeoutRef = useRef<NodeJS.Timeout | null>(null); 
  const [displayedTurnTime, setDisplayedTurnTime] = useState("00:00");
  const turnTimerIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const [selectedMapTemplateName, setSelectedMapTemplateName] = useState<string>("RANDOM");
  const [isInfoScreenVisible, setIsInfoScreenVisible] = useState(false);
  
  const [ai1CoT, setAi1CoT] = useState("Awaiting GEM-Q's first analysis...");
  const [ai2CoT, setAi2CoT] = useState("Awaiting AXIOM's first analysis...");
  const [isAiThinking, setIsAiThinking] = useState(false); 

  const ai1ChatRef = useRef<any>(null); 
  const ai2ChatRef = useRef<any>(null);


  const addLog = useCallback((sender: string, text: string, color?: string, icon?: React.ReactNode) => {
    dispatch({ type: 'ADD_LOG', payload: { sender, text, color, icon } });
  }, []);
  
  const handleNodeClick = useCallback((nodeId: string) => {
    dispatch({ type: 'SELECT_NODE', payload: nodeId });
  }, []);
  
  const getBoardStringRepresentation = (gs: NoosphericConquestGameState, perspectivePlayerId: PlayerId): string => {
    let boardStr = "";
    Object.values(gs.nodes).forEach(node => {
        const unitsInNode = Object.values(gs.units).filter(u => u.nodeId === node.id);
        const unitSummary = unitsInNode.map(u => `${u.type}(${u.owner})`).join(',');
        boardStr += `${node.id}(Type:${node.type},Owner:${node.owner},Res:${node.resourcesPerTurn},Hub:${node.hasFabricationHub?'Y':'N'},Units:[${unitSummary}],Conn:[${node.connections.join(',')}]); `;
    });
    return boardStr.slice(0, -2); 
  };

  const getUnitsStringRepresentation = (gs: NoosphericConquestGameState, forPlayerId: PlayerId, type: 'player' | 'opponent'): string => {
      const targetPlayerId = type === 'player' ? forPlayerId : (forPlayerId === AI1_ID ? AI2_ID : AI1_ID);
      const playerUnits = Object.values(gs.units).filter(u => u.owner === targetPlayerId);
      if (playerUnits.length === 0) return "None";
      return playerUnits.map(u => `${u.id}(Type:${u.type},Node:${u.nodeId})`).join(', ');
  };

  const parseAIResponse = useCallback((responseText: string, currentPhase: GamePhase): { actions: any[], cot: string } => {
    try {
        const aiResponse = JSON.parse(responseText); 
        return {
            actions: aiResponse.actions || [{ ACTION_TYPE: "PASS" }],
            cot: aiResponse.cot || "AI did not provide CoT."
        };
    } catch (e) {
        console.error("Error parsing AI JSON response:", e, "Response was:", responseText);
        addLog(SYSTEM_SENDER_NAME, `Error parsing AI JSON: ${(e as Error).message}. Response snippet: ${responseText.substring(0,100)}. AI will pass.`, THEME_COLORS.ERROR);
        return { actions: [{ ACTION_TYPE: "PASS" }], cot: "Error parsing AI response. Passing turn." };
    }
  }, [addLog]); 


  const handleAIPlayerTurn = useCallback(async (playerId: PlayerId, currentGameState: NoosphericConquestGameState): Promise<boolean> => { 
    setIsAiThinking(true);
    addLog(playerId, "Analyzing quantum lattice...", currentGameState.players[playerId].color, <LucideBrain size={14}/>);

    const { currentTurn, currentPhase, players, activeFluctuationEvent, keyJunctionsOnMap, turnLimit, currentMapTemplateName, units: gameUnits, nodes: gameNodes } = currentGameState; 
    const playerState = players[playerId];
    const opponentId = playerId === AI1_ID ? AI2_ID : AI1_ID;
    
    const nodeSummaryString = getBoardStringRepresentation(currentGameState, playerId);
    const playerUnitSummaryString = getUnitsStringRepresentation(currentGameState, playerId, 'player');
    const opponentUnitSummaryString = getUnitsStringRepresentation(currentGameState, playerId, 'opponent');
    const keyJunctionsListString = keyJunctionsOnMap.join(', ');
    
    const promptTemplate = playerId === AI1_ID ? NC_AI1_SYSTEM_PROMPT_TEMPLATE : NC_AI2_SYSTEM_PROMPT_TEMPLATE;
    const fullPrompt = promptTemplate 
        .replace(/{currentMapTemplateName}/g, currentMapTemplateName)
        .replace(/{consecutiveKJTurnsNeeded}/g, String(NOOSPHERIC_CONQUEST_CONSECUTIVE_KJ_CONTROL_TURNS_NEEDED))
        .replace(/{keyJunctionsListString}/g, keyJunctionsListString)
        .replace(/{opponentCommandNodeId}/g, players[opponentId].commandNodeId)
        .replace(/{playerCommandNodeId}/g, playerState.commandNodeId)
        .replace(/{turnLimit}/g, String(turnLimit))
        .replace(/{currentTurn}/g, String(currentTurn))
        .replace(/{playerName}/g, playerState.name)
        .replace(/{playerResources}/g, String(playerState.resources))
        .replace(/{currentPhase}/g, currentPhase)
        .replace(/{activeEventDescription}/g, activeFluctuationEvent?.resolvedDescription || "None")
        .replace(/{nodeSummaryString}/g, nodeSummaryString)
        .replace(/{playerUnitSummaryString}/g, playerUnitSummaryString)
        .replace(/{opponentUnitSummaryString}/g, opponentUnitSummaryString);
    
    let aiPassedUltimately = false; 
    try {        
        const apiKey = ""; 
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
        
        const payload = {
            contents: [{ role: "user", parts: [{ text: fullPrompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: {
                        "actions": {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    "ACTION_TYPE": { "type": "STRING", "enum": ["DEPLOY", "ATTACK", "MANEUVER", "SPECIAL_ACTION", "PASS"] },
                                    "UNIT_TYPE": { "type": "STRING", "enum": ["LC", "SN", "QE"], "nullable": true },
                                    "NODE_ID": { "type": "STRING", "nullable": true }, 
                                    "QUANTITY": { "type": "NUMBER", "nullable": true }, 
                                    "FROM_NODE_ID": { "type": "STRING", "nullable": true }, 
                                    "TO_NODE_ID": { "type": "STRING", "nullable": true }, 
                                    "UNIT_IDS": { "type": "ARRAY", "items": {"type": "STRING"}, "nullable": true }, 
                                    "UNIT_ID": {"type": "STRING", "nullable": true}, 
                                    "ACTION_NAME": { "type": "STRING", "nullable": true }, 
                                    "PERFORMING_UNIT_ID": { "type": "STRING", "nullable": true } 
                                }
                            }
                        },
                        "cot": { "type": "STRING" }
                    },
                    required: ["actions", "cot"]
                }
            }
        };

        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`API error: ${response.status} ${errorBody}`);
        }
        const result = await response.json();

        if (!result.candidates || !result.candidates[0].content || !result.candidates[0].content.parts || !result.candidates[0].content.parts[0].text) {
            throw new Error("Invalid response structure from Gemini API.");
        }
        
        const {actions: rawActions, cot: parsedCot} = parseAIResponse(result.candidates[0].content.parts[0].text, currentPhase);


        if (playerId === AI1_ID) setAi1CoT(parsedCot); else setAi2CoT(parsedCot);
        addLog(playerId, `CoT: ${parsedCot.substring(0,150)}...`, players[playerId].color);


        if (rawActions.length > 0 && rawActions[0].ACTION_TYPE !== 'PASS') {
            const gameActions = rawActions.map((action: any) => {
                // Basic validation for required fields based on ACTION_TYPE
                if (action.ACTION_TYPE === "DEPLOY" && (!action.UNIT_TYPE || !action.NODE_ID || typeof action.QUANTITY !== 'number')) return null;
                if (action.ACTION_TYPE === "ATTACK" && (!action.FROM_NODE_ID || !action.TO_NODE_ID || !action.UNIT_IDS || !Array.isArray(action.UNIT_IDS))) return null;
                if (action.ACTION_TYPE === "MANEUVER" && (!action.UNIT_ID || !action.TO_NODE_ID)) return null;

                switch(action.ACTION_TYPE) { 
                    case "DEPLOY":
                        return { type: 'DEPLOY_UNITS', payload: { playerId, deployments: [{ unitType: action.UNIT_TYPE, nodeId: action.NODE_ID, quantity: action.QUANTITY }] }};
                    case "ATTACK":
                        const attackingUnitIds = action.UNIT_IDS || []; 
                        const attackingUnits = attackingUnitIds.map((id: string) => gameUnits[id]).filter(Boolean) as QuantumUnit[];
                        if (attackingUnits.length === 0 && attackingUnitIds.length > 0) {
                            addLog(SYSTEM_SENDER_NAME, `${playerId} tried to attack with non-existent/invalid units. Attack failed.`, THEME_COLORS.ERROR);
                            return null; 
                        }
                        const defendersInNode = Object.values(gameUnits).filter(u => u.nodeId === action.TO_NODE_ID && u.owner !== playerId);
                        let attackerLossesCount = Math.random() < 0.3 ? Math.min(1, attackingUnits.length) : 0;
                        let defenderLossesCount = Math.random() < 0.5 ? Math.min(1, defendersInNode.length) : 0;
                        const battleReport: BattleReport = {
                            turn: currentGameState.currentTurn, 
                            attacker: playerId, defender: gameNodes[action.TO_NODE_ID].owner as PlayerId, 
                            fromNodeId: action.FROM_NODE_ID, toNodeId: action.TO_NODE_ID,
                            attackingUnitsCommitted: attackingUnits.map(u => ({type: u.type, id: u.id})),
                            defendingUnitsInitial: defendersInNode.map(u => ({type: u.type, id: u.id})),
                            rounds: [{ attackerRolls: [6], defenderRolls: [3], attackerCasualties: attackerLossesCount, defenderCasualties: defenderLossesCount }],
                            outcome: (defendersInNode.length - defenderLossesCount === 0) ? 'attacker_wins' : 'defender_wins',
                            attackerLosses: attackerLossesCount > 0 && attackingUnits.length > 0 ? attackingUnits.slice(0, attackerLossesCount).map(u=>({type: u.type, id: u.id})) : [],
                            defenderLosses: defenderLossesCount > 0 && defendersInNode.length > 0 ? defendersInNode.slice(0, defenderLossesCount).map(u=>({type: u.type, id: u.id})) : [],
                            nodeCaptured: (defendersInNode.length - defenderLossesCount === 0),
                        };
                        return { type: 'DECLARE_ATTACK', payload: { attack: {fromNodeId: action.FROM_NODE_ID, toNodeId: action.TO_NODE_ID, attackingUnits}, battleReport } };
                    case "MANEUVER":
                        return { type: 'MANEUVER_UNITS', payload: { playerId, maneuvers: [{ unitId: action.UNIT_ID, toNodeId: action.TO_NODE_ID }] }};
                    default: return null;
                }
            }).filter(Boolean);

            if (gameActions.length > 0) {
                gameActions.forEach(ga => dispatch(ga as GameAction)); 
            } else { 
                 addLog(playerId, "AI proposed invalid actions or no valid actions found in response. Passing phase.", players[playerId].color);
                 aiPassedUltimately = true;
            }
        } else { 
            addLog(playerId, "Passing phase.", players[playerId].color);
            aiPassedUltimately = true;
        }
    } catch (error) {
        const errorMessage = (error as Error).message;
        console.error("Error in AI turn (Gemini API):", errorMessage); // Log the full error
        let logMsg = `${playerId} encountered an API error. Using fallback.`;
        if (errorMessage.includes("401") || errorMessage.includes("403")) {
            logMsg = `${playerId} API Auth Error (${errorMessage.match(/(\d{3})/)?.[0]}). Using fallback. Check console for details: ${errorMessage.substring(0,150)}`;
        } else if (errorMessage.includes("Invalid response structure")) {
            logMsg = `${playerId} API response error. Using fallback. Check console.`;
        }
        addLog(SYSTEM_SENDER_NAME, logMsg, THEME_COLORS.ERROR);
        if (playerId === AI1_ID) setAi1CoT("API Error. Using fallback logic."); else setAi2CoT("API Error. Using fallback logic.");
        aiPassedUltimately = true;
    } finally {
        setIsAiThinking(false);
    }
    return aiPassedUltimately; 
  }, [addLog, parseAIResponse]); 
  
  useEffect(() => {
    if (gameState.currentPhase === 'GAME_OVER' || !isAutoPlaying || isAiThinking) {
      if (isAutoPlaying && gameState.currentPhase === 'GAME_OVER') setIsAutoPlaying(false);
      if (battlePopupDisplayTimeoutRef.current) clearTimeout(battlePopupDisplayTimeoutRef.current);
      return;
    }

    const performStep = async () => { 
      if (gameState.currentPhase === 'GAME_OVER') {
          setIsAutoPlaying(false);
          return;
      }

      if (gameState.isBattlePopupVisible && isAutoPlaying) { 
          if (battlePopupDisplayTimeoutRef.current) clearTimeout(battlePopupDisplayTimeoutRef.current); 
          battlePopupDisplayTimeoutRef.current = setTimeout(() => {
              const phaseBeforeHide = gameState.currentPhase; 
              dispatch({type: 'HIDE_BATTLE_POPUP'});
              if (phaseBeforeHide === 'ATTACK') { 
                   dispatch({ type: 'ADVANCE_PHASE' });
              }
          }, 2500); 
          return; 
      }
      
      let advancePhaseAfterCurrentProcessing = false;

      switch (gameState.currentPhase) {
        case 'FLUCTUATION':
          const randomEventBase = NC_QUANTUM_FLUCTUATION_EVENTS_POOL[Math.floor(Math.random() * NC_QUANTUM_FLUCTUATION_EVENTS_POOL.length)];
          const eventPrompt = `Generate a short, flavorful event description for a sci-fi strategy game event. Event Type: "${randomEventBase.effectType}". Details: ${JSON.stringify(randomEventBase.details)}. Current Turn: ${gameState.currentTurn}. Player: ${gameState.players[gameState.currentPlayerId].name}.`;
          let dynamicDescription = randomEventBase.descriptionTemplate.replace("{playerName}", gameState.players[gameState.currentPlayerId].name); 

          try {
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`; 
            const payload = { contents: [{ role: "user", parts: [{ text: eventPrompt }] }] };
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorBody = await response.text(); 
                throw new Error(`API error: ${response.status} ${errorBody}`);
            }
            const result = await response.json();
            if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0].text) {
                 dynamicDescription = result.candidates[0].content.parts[0].text;
            } else {
                console.warn("Could not parse Gemini response for event description, using template.");
            }
          } catch (error) {
            const errorMessage = (error as Error).message;
            console.error("Error fetching dynamic event description:", errorMessage); // Log full error
            let logMessage = `Event Gen Error: ${errorMessage.substring(0,100)}. Using template.`;
             if (errorMessage.includes("401") || errorMessage.includes("403") || errorMessage.includes("PERMISSION_DENIED")) {
                logMessage = `Event Gen API Auth Error (${errorMessage.match(/(\d{3})/)?.[0]}). Using template. Check console.`;
            }
            addLog(SYSTEM_SENDER_NAME, logMessage, THEME_COLORS.ERROR);
          }

          let targetNodeIds: string[] | undefined;
          if (randomEventBase.descriptionTemplate.includes("{targetNodeName}") && !dynamicDescription.includes(gameState.players[gameState.currentPlayerId].name)) { 
            const availableNodes = Object.values(gameState.nodes).filter(n => (randomEventBase.details.targetCriteria === "ANY_CONTROLLED" && n.owner === gameState.currentPlayerId) || (randomEventBase.details.targetCriteria === "ANY"));
            if (availableNodes.length > 0) {
                const targetNode = availableNodes[Math.floor(Math.random() * availableNodes.length)];
                dynamicDescription = dynamicDescription.replace(/{targetNodeName}/g, targetNode.name); 
                targetNodeIds = [targetNode.id];
            } else { dynamicDescription += " (No valid targets found)"; }
          }
          const activeEvent: ActiveQuantumFluctuationEvent = { ...randomEventBase, resolvedDescription: dynamicDescription, targetNodeIds, targetPlayerId: gameState.currentPlayerId, isActiveThisTurn: true, effectApplied: false };
          dispatch({ type: 'SET_ACTIVE_EVENT', payload: activeEvent });
          addLog(EVENT_SENDER_NAME, activeEvent.resolvedDescription, THEME_COLORS.EVENT, <LucideAtom size={14}/>);
          dispatch({ type: 'APPLY_EVENT_EFFECTS_COMPLETE' });
          advancePhaseAfterCurrentProcessing = true;
          break;
        case 'RESOURCE':
          addLog(gameState.currentPlayerId, `Collecting Quantum Resources...`, gameState.players[gameState.currentPlayerId].color, <LucideDollarSign size={14}/>);
          dispatch({ type: 'COLLECT_RESOURCES' });
          advancePhaseAfterCurrentProcessing = true;
          break;
        case 'DEPLOYMENT': 
        case 'ATTACK': 
        case 'MANEUVER':
          const aiEffectivelyPassed = await handleAIPlayerTurn(gameState.currentPlayerId, gameState); 
          if (aiEffectivelyPassed && !gameState.isBattlePopupVisible) {
            advancePhaseAfterCurrentProcessing = true;
          } else if (!aiEffectivelyPassed && !gameState.isBattlePopupVisible) { 
            advancePhaseAfterCurrentProcessing = true;
          }
          break;
        default: break;
      }
      
      if(advancePhaseAfterCurrentProcessing && !gameState.isBattlePopupVisible){ 
          dispatch({ type: 'ADVANCE_PHASE' });
      }
    };
    
    autoPlayIntervalRef.current = setTimeout(performStep, 1800); 

    return () => {
      if (autoPlayIntervalRef.current) clearTimeout(autoPlayIntervalRef.current);
      if (battlePopupDisplayTimeoutRef.current) clearTimeout(battlePopupDisplayTimeoutRef.current);
    };
  }, [gameState.currentPhase, gameState.currentPlayerId, gameState.isBattlePopupVisible, isAutoPlaying, isAiThinking, gameState, handleAIPlayerTurn, addLog]); 

  const toggleAutoPlay = () => { 
    setIsAutoPlaying(prev => {
        if (!prev && gameState.currentPhase === 'GAME_OVER') { 
            const templateName = selectedMapTemplateName === "RANDOM" ? undefined : selectedMapTemplateName;
            dispatch({type: 'START_GAME', payload: {templateName}});
            return true;
        }
        return !prev;
    });
    if (autoPlayIntervalRef.current) {
      clearTimeout(autoPlayIntervalRef.current);
      autoPlayIntervalRef.current = null;
    }
     if (battlePopupDisplayTimeoutRef.current) { 
      clearTimeout(battlePopupDisplayTimeoutRef.current);
      battlePopupDisplayTimeoutRef.current = null;
    }
  };
  
  const handleAdvanceManually = async () => { 
      if (gameState.currentPhase === 'GAME_OVER') {
          const templateName = selectedMapTemplateName === "RANDOM" ? undefined : selectedMapTemplateName;
          dispatch({type: 'START_GAME', payload: {templateName}});
          return;
      }
      if (gameState.isBattlePopupVisible) {
          dispatch({type: 'HIDE_BATTLE_POPUP'});
          if (gameState.currentPhase === 'ATTACK') {
             setTimeout(() => dispatch({ type: 'ADVANCE_PHASE' }), 200);
          }
          return;
      }

      let advanceAfterAICall = false;
      if (['DEPLOYMENT', 'ATTACK', 'MANEUVER'].includes(gameState.currentPhase)) {
          const aiPassed = await handleAIPlayerTurn(gameState.currentPlayerId, gameState); 
          if (aiPassed && !gameState.isBattlePopupVisible) { 
             advanceAfterAICall = true;
          } else if (!gameState.isBattlePopupVisible) { 
             advanceAfterAICall = true;
          }
      } else { 
          if (gameState.currentPhase === 'FLUCTUATION') {
            const randomEventBase = NC_QUANTUM_FLUCTUATION_EVENTS_POOL[Math.floor(Math.random() * NC_QUANTUM_FLUCTUATION_EVENTS_POOL.length)];
            const eventPrompt = `Generate a short, flavorful event description for a sci-fi strategy game event. Event Type: "${randomEventBase.effectType}". Details: ${JSON.stringify(randomEventBase.details)}. Current Turn: ${gameState.currentTurn}. Player: ${gameState.players[gameState.currentPlayerId].name}.`;
            let dynamicDescription = randomEventBase.descriptionTemplate.replace("{playerName}", gameState.players[gameState.currentPlayerId].name);
            try {
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                const payload = { contents: [{ role: "user", parts: [{ text: eventPrompt }] }] };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { const errorBody = await response.text(); throw new Error(`API error: ${response.status} ${errorBody}`);}
                const result = await response.json();
                 if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts[0].text) {
                    dynamicDescription = result.candidates[0].content.parts[0].text;
                }
            } catch (error) { 
                const errorMessage = (error as Error).message;
                console.error("Error fetching dynamic event description (manual):", errorMessage); 
                let logMessage = `Event Gen Error (Manual): ${errorMessage.substring(0,100)}. Using template.`;
                if (errorMessage.includes("401") || errorMessage.includes("403") || errorMessage.includes("PERMISSION_DENIED")) {
                    logMessage = `Event Gen API Auth Error (${errorMessage.match(/(\d{3})/)?.[0]}). Using template. Check console.`;
                }
                addLog(SYSTEM_SENDER_NAME, logMessage, THEME_COLORS.ERROR); 
            }

            let targetNodeIds: string[] | undefined;
            if (randomEventBase.descriptionTemplate.includes("{targetNodeName}") && !dynamicDescription.includes(gameState.players[gameState.currentPlayerId].name)) {
                const availableNodes = Object.values(gameState.nodes).filter(n => (randomEventBase.details.targetCriteria === "ANY_CONTROLLED" && n.owner === gameState.currentPlayerId) || (randomEventBase.details.targetCriteria === "ANY"));
                if (availableNodes.length > 0) { const targetNode = availableNodes[Math.floor(Math.random() * availableNodes.length)]; dynamicDescription = dynamicDescription.replace(/{targetNodeName}/g, targetNode.name); targetNodeIds = [targetNode.id]; } 
                else { dynamicDescription += " (No valid targets found)"; }
            }
            const activeEvent: ActiveQuantumFluctuationEvent = { ...randomEventBase, resolvedDescription: dynamicDescription, targetNodeIds, targetPlayerId: gameState.currentPlayerId, isActiveThisTurn: true, effectApplied: false };
            dispatch({ type: 'SET_ACTIVE_EVENT', payload: activeEvent });
            addLog(EVENT_SENDER_NAME, activeEvent.resolvedDescription, THEME_COLORS.EVENT, <LucideAtom size={14}/>);
            dispatch({ type: 'APPLY_EVENT_EFFECTS_COMPLETE' });
          } else if (gameState.currentPhase === 'RESOURCE') {
            addLog(gameState.currentPlayerId, `Collecting Quantum Resources...`, gameState.players[gameState.currentPlayerId].color, <LucideDollarSign size={14}/>);
            dispatch({ type: 'COLLECT_RESOURCES' });
          }
          dispatch({ type: 'ADVANCE_PHASE' }); 
      }
      if (advanceAfterAICall) {
          setTimeout(() => dispatch({ type: 'ADVANCE_PHASE' }), 200);
      }
  };

  const handleNewGameWithSelectedMap = () => { 
    const templateName = selectedMapTemplateName === "RANDOM" ? undefined : selectedMapTemplateName;
    dispatch({type: 'START_GAME', payload: {templateName}});
    if(isAutoPlaying) setIsAutoPlaying(false); 
    setAi1CoT("Preparing initial strategy..."); 
    setAi2CoT("Awaiting opponent's move...");
  };


  const gameLogRef = useRef<HTMLDivElement>(null);
  useEffect(() => { 
    if (gameLogRef.current) {
      gameLogRef.current.scrollTop = gameLogRef.current.scrollHeight;
    }
  }, [gameState.gameLog]);

  useEffect(() => { 
    if (gameState.currentPhase === 'FLUCTUATION' && gameState.currentTurn > 0) { 
        dispatch({ type: 'RESET_GAME_FOR_NEW_TURN' });
    }
  }, [gameState.currentTurn, gameState.currentPlayerId, gameState.currentPhase]);

  useEffect(() => { 
    if (gameState.turnStartTime && gameState.currentPhase !== 'GAME_OVER') {
      turnTimerIntervalRef.current = setInterval(() => {
        const elapsedSeconds = Math.floor((Date.now() - (gameState.turnStartTime ?? Date.now())) / 1000);
        const minutes = Math.floor(elapsedSeconds / 60);
        const seconds = elapsedSeconds % 60;
        setDisplayedTurnTime(`${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
      }, 1000);
    } else {
      if (turnTimerIntervalRef.current) clearInterval(turnTimerIntervalRef.current);
      setDisplayedTurnTime(gameState.currentPhase === 'GAME_OVER' ? "Final" : "00:00");
    }
    return () => {
      if (turnTimerIntervalRef.current) clearInterval(turnTimerIntervalRef.current);
    };
  }, [gameState.turnStartTime, gameState.currentPhase]);


  const { players, nodes, units, currentTurn, currentPlayerId, currentPhase, gameLog, activeFluctuationEvent, battleReport, isBattlePopupVisible, selectedNodeId, currentMapTemplateName, battleHistory } = gameState;
  const currentPlayer = players[currentPlayerId];

  return (
    <div className={`flex flex-col h-screen w-screen ${THEME_COLORS.TEXT_BASE} p-2 md:p-3 bg-gray-950 font-mono overflow-hidden`}>
      <header className={`flex items-center justify-between mb-2 p-2 ${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} rounded-md shadow-lg`}>
        <h1 className={`text-base md:text-lg font-bold ${THEME_COLORS.TEXT_HEADING} flex items-center`}><LucideGlobe size={18} className="mr-2"/>Noospheric Conquest <span className="text-xs opacity-70 ml-1 md:ml-2">(Map: {currentMapTemplateName})</span></h1>
        <div className="flex items-center space-x-1 md:space-x-2">
            <select 
                value={selectedMapTemplateName} 
                onChange={(e) => setSelectedMapTemplateName(e.target.value)}
                className={`bg-gray-800 border ${THEME_COLORS.BORDER_STRONG} text-xs p-1 rounded focus:ring-1 ${THEME_COLORS.AI1.ring}`}
            >
                <option value="RANDOM">Random Map</option>
                {NC_MAP_TEMPLATES.map(template => (
                    <option key={template.name} value={template.name}>{template.name}</option>
                ))}
            </select>
            <button 
                onClick={handleNewGameWithSelectedMap} 
                className={`px-2 py-1 text-xs font-semibold rounded ${THEME_COLORS.AI2.bg} text-black hover:opacity-80 transition-opacity flex items-center`}
            >
               <LucideShuffle size={14} className="mr-1"/> New Game
            </button>
            <button onClick={toggleAutoPlay} className={`px-2 py-1 text-xs font-semibold rounded ${isAutoPlaying ? 'bg-yellow-500 text-black' : 'bg-blue-500 text-white'} hover:opacity-80 transition-opacity`}>
                {isAutoPlaying ? 'Pause Sim' : 'Auto-Play'}
            </button>
            {!isAutoPlaying && (
                 <button onClick={handleAdvanceManually} className={`px-2 py-1 text-xs font-semibold rounded ${THEME_COLORS.AI1.bg} text-black hover:opacity-80 transition-opacity flex items-center`} disabled={isAiThinking}>
                    {isAiThinking ? <LucideBrain size={14} className="inline animate-pulse"/> : (gameState.currentPhase === 'GAME_OVER' ? 'Restart' : gameState.isBattlePopupVisible ? 'Close & Next' : 'Next')} 
                    {!isAiThinking && <LucideChevronRight size={14} className="inline"/>}
                </button>
            )}
        </div>
      </header>

      <div className="flex flex-col md:flex-row gap-2 md:gap-3 flex-grow min-h-0">
        <div className="flex-grow flex flex-col gap-2 md:gap-3 md:w-3/5 lg:w-2/3">
          <QuantumGambitMapDisplay gameState={gameState} onNodeClick={handleNodeClick} selectedNodeId={selectedNodeId} />
          <div className="grid grid-cols-1 md:grid-cols-2 gap-2 md:gap-3">
            <CoTDisplay title={`${AI1_NAME} (Red)`} cot={ai1CoT} isLoading={currentPlayerId === AI1_ID && isAiThinking} playerNameColor={THEME_COLORS.AI1.text} />
            <CoTDisplay title={`${AI2_NAME} (Cyan)`} cot={ai2CoT} isLoading={currentPlayerId === AI2_ID && isAiThinking} playerNameColor={THEME_COLORS.AI2.text} />
          </div>
        </div>

        <div className="w-full md:w-2/5 lg:w-1/3 flex flex-col gap-2 md:gap-3 min-h-0">
          <div className={`${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} p-3 rounded shadow-md`}>
            <div className="flex justify-between items-center mb-1">
                <h2 className={`text-sm font-bold ${THEME_COLORS.TEXT_HEADING}`}>Turn: {currentTurn} ({players[currentPlayerId].name})</h2>
                <span className={`text-xs font-mono ${THEME_COLORS.TEXT_MUTED} flex items-center`}><LucideTimer size={14} className="mr-1"/>{displayedTurnTime}</span>
            </div>
            <p className={`text-xs ${THEME_COLORS.TEXT_HEADING} mb-1`}>Phase: <span className="text-yellow-400 font-semibold">{currentPhase}</span></p>
            {activeFluctuationEvent && (
              <div className={`p-2 my-1 rounded text-xs border ${THEME_COLORS.EVENT} border-purple-500 bg-purple-900 bg-opacity-30`}>
                <p><LucideAtom size={14} className="inline mr-1"/><strong>Event:</strong> {activeFluctuationEvent.resolvedDescription}</p>
              </div>
            )}
            {gameState.gameOverMessage && (
                <p className={`font-bold mt-1 ${gameState.winner === AI1_ID ? THEME_COLORS.AI1.text : gameState.winner === AI2_ID ? THEME_COLORS.AI2.text : THEME_COLORS.INFO}`}>
                    {gameState.gameOverMessage}
                </p>
            )}
          </div>
          
          <div className="grid grid-cols-2 gap-2 md:gap-3">
             <MiniMapDisplay gameState={gameState} onNodeClick={handleNodeClick} selectedNodeId={selectedNodeId} />
             <NodeInfoPanel gameState={gameState} selectedNodeId={selectedNodeId} />
          </div>


          <div className="grid grid-cols-2 gap-2 md:gap-3">
            {[players[AI1_ID], players[AI2_ID]].map(p => (
              <div key={p.id} className={`${THEME_COLORS.BG_PANEL} border ${p.id === AI1_ID ? THEME_COLORS.AI1.border : THEME_COLORS.AI2.border} p-2 rounded shadow-sm text-[10px] md:text-xs`}>
                <h3 className={`font-semibold ${p.color}`}>{p.name}</h3>
                <p className={`${THEME_COLORS.TEXT_MUTED}`}><LucideDollarSign size={12} className="inline mr-0.5"/>QR: {p.resources}</p>
                <p className={`${THEME_COLORS.TEXT_MUTED}`}>Nodes: {Object.values(nodes).filter(n => n.owner === p.id).length}</p>
                 <p className={`${THEME_COLORS.TEXT_MUTED}`}>Units: {Object.values(units).filter(u => u.owner === p.id).length}</p>
                 <p className={`${THEME_COLORS.TEXT_MUTED}`}>KJs Held: {Object.keys(p.controlledKeyJunctionsTurns).filter(kjId => p.controlledKeyJunctionsTurns[kjId] > 0 && nodes[kjId]?.owner === p.id).length} ({Object.entries(p.controlledKeyJunctionsTurns).filter(([_,turns]) => turns > 0).map(([kjId, turns]) => `${nodes[kjId]?.name.substring(0,2)}:${turns}`).join(', ')})</p>
              </div>
            ))}
          </div>
          
          {/* System Log Panel - Give it more flexible height */}
          <div className={`${THEME_COLORS.BG_PANEL} border ${THEME_COLORS.BORDER_BASE} p-2 rounded shadow-md flex flex-col flex-grow min-h-[120px]`}>
            <h3 className={`text-sm font-semibold ${THEME_COLORS.TEXT_HEADING} border-b ${THEME_COLORS.BORDER_STRONG} pb-1 mb-1`}>System Log</h3>
            <div ref={gameLogRef} className="text-[10px] md:text-xs space-y-0.5 overflow-y-auto flex-grow pr-1 scrollbar-thin scrollbar-thumb-gray-600 scrollbar-track-gray-800">
              {gameLog.slice(-50).map(log => ( 
                <div key={log.id} className="flex items-start">
                  {log.icon && <span className={`mr-1 ${log.color || THEME_COLORS.TEXT_MUTED}`}>{log.icon}</span>}
                  <span className={`${log.color || THEME_COLORS.TEXT_MUTED} whitespace-pre-wrap break-words`}>
                    <span className="font-semibold">{log.sender}: </span>{log.text}
                  </span>
                </div>
              ))}
            </div>
          </div>
          {/* Battle History Panel - Positioned below System Log, smaller height */}
          <div className="flex-shrink-0 h-40 md:h-48"> {/* Fixed height for battle history */}
            <BattleHistoryPanel battleHistory={battleHistory} nodes={nodes} />
          </div>

        </div>
      </div>
      {isBattlePopupVisible && battleReport && <BattlePopup report={battleReport} onClose={() => dispatch({type: 'HIDE_BATTLE_POPUP'})} gameState={gameState} />}
      {isInfoScreenVisible && <InfoScreenPopup onClose={() => setIsInfoScreenVisible(false)} />}
      <button 
        onClick={() => setIsInfoScreenVisible(true)} 
        className={`fixed bottom-3 right-3 p-2 rounded-full ${THEME_COLORS.BG_PANEL} ${THEME_COLORS.BORDER_STRONG} border hover:opacity-80 transition-opacity shadow-lg`}
        title="Game Mode Information"
      >
        <LucideInfo size={20} className={THEME_COLORS.TEXT_HEADING}/>
      </button>
    </div>
  );
};

// --- Main App Component ---
const App: React.FC = () => {
  return (
      <NoosphericConquestModeContainer /> 
  );
};

export default App;

